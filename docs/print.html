<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>KusionStack 实战</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="如何用 KusionStack 部署运维 Kubernetes 应用">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="book.html">封面</a></li><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="chapter-item expanded "><a href="ch1-intro/index.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1-intro/ch1.1-backend.html"><strong aria-hidden="true">1.1.</strong> 背景</a></li><li class="chapter-item expanded "><a href="ch1-intro/ch1.2-kcl.html"><strong aria-hidden="true">1.2.</strong> KCL 语言</a></li><li class="chapter-item expanded "><a href="ch1-intro/ch1.3-konfig.html"><strong aria-hidden="true">1.3.</strong> Konfig 模型库</a></li><li class="chapter-item expanded "><a href="ch1-intro/ch1.4-kusion.html"><strong aria-hidden="true">1.4.</strong> Kusion 用户界面</a></li><li class="chapter-item expanded "><a href="ch1-intro/ch1.5-ide.html"><strong aria-hidden="true">1.5.</strong> IDE 插件</a></li></ol></li><li class="chapter-item expanded "><a href="ch2-hello-kusion/index.html"><strong aria-hidden="true">2.</strong> 你好 Kusion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2-hello-kusion/ch2.1-init.html"><strong aria-hidden="true">2.1.</strong> 初始化工程</a></li><li class="chapter-item expanded "><a href="ch2-hello-kusion/ch2.2-apply.html"><strong aria-hidden="true">2.2.</strong> Apply 子命令</a></li></ol></li><li class="chapter-item expanded "><a href="ch3-internal/index.html"><strong aria-hidden="true">3.</strong> Kusion 核心概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3-internal/ch3.1-arch.html"><strong aria-hidden="true">3.1.</strong> 整体架构</a></li><li class="chapter-item expanded "><a href="ch3-internal/ch3.2-project-stack.html"><strong aria-hidden="true">3.2.</strong> Project &amp; Stack</a></li><li class="chapter-item expanded "><a href="ch3-internal/ch3.3-state-backends.html"><strong aria-hidden="true">3.3.</strong> State &amp; Backends</a></li><li class="chapter-item expanded "><a href="ch3-internal/ch3.4-connect-x.html"><strong aria-hidden="true">3.4.</strong> 和上游下游的关系</a></li></ol></li><li class="chapter-item expanded "><a href="ch4-devops/index.html"><strong aria-hidden="true">4.</strong> 场景: 日常运维</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch4-devops/ch4.1-deploy.html"><strong aria-hidden="true">4.1.</strong> 部署 Deployment</a></li><li class="chapter-item expanded "><a href="ch4-devops/ch4.2-monitor.html"><strong aria-hidden="true">4.2.</strong> 为应用配置监控</a></li><li class="chapter-item expanded "><a href="ch4-devops/ch4.3-expand-resource-cap.html"><strong aria-hidden="true">4.3.</strong> 扩展应用资源容量</a></li><li class="chapter-item expanded "><a href="ch4-devops/ch4.4-app-image-upgrade.html"><strong aria-hidden="true">4.4.</strong> 镜像升级</a></li><li class="chapter-item expanded "><a href="ch4-devops/ch4.5-ext.html"><strong aria-hidden="true">4.5.</strong> 补充说明</a></li></ol></li><li class="chapter-item expanded "><a href="ch5-connect-x/index.html"><strong aria-hidden="true">5.</strong> 场景: 对接社区生态</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch5-connect-x/ch5.1-openapi.html"><strong aria-hidden="true">5.1.</strong> OpenAPI</a></li><li class="chapter-item expanded "><a href="ch5-connect-x/ch5.2-terraform.html"><strong aria-hidden="true">5.2.</strong> Terraform</a></li></ol></li><li class="chapter-item expanded "><a href="ch6-multi-cloud/index.html"><strong aria-hidden="true">6.</strong> 多平台: 对接阿里云生态</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch6-multi-cloud/ch6.1-ecs.html"><strong aria-hidden="true">6.1.</strong> ECS 云主机</a></li><li class="chapter-item expanded "><a href="ch6-multi-cloud/ch6.2-slb.html"><strong aria-hidden="true">6.2.</strong> SLB 负载均衡</a></li></ol></li><li class="chapter-item expanded "><a href="ch7-opensource/index.html"><strong aria-hidden="true">7.</strong> 开源社区</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch7-opensource/ch7.1-support.html"><strong aria-hidden="true">7.1.</strong> 寻求帮助</a></li><li class="chapter-item expanded "><a href="ch7-opensource/ch7.2-contribute-docs.html"><strong aria-hidden="true">7.2.</strong> 贡献文档</a></li><li class="chapter-item expanded "><a href="ch7-opensource/ch7.3-contribute-code.html"><strong aria-hidden="true">7.3.</strong> 贡献代码</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">8.</strong> 附录</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/a-faq.html"><strong aria-hidden="true">8.1.</strong> 附录 A: FAQ</a></li><li class="chapter-item expanded "><a href="appendix/b-kcl.html"><strong aria-hidden="true">8.2.</strong> 附录 B: KCL 语法</a></li><li class="chapter-item expanded "><a href="appendix/c-ref.html"><strong aria-hidden="true">8.3.</strong> 附录 C: 链接</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">KusionStack 实战</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KusionStack/kusion-in-action-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kusionstack-实战"><a class="header" href="#kusionstack-实战">KusionStack 实战</a></h1>
<p>本书主要讲解如何使用 KusionStack 工具部署 Kubernetes 相关应用。</p>
<p><img src="./images/logo/kusionstack-color2.png" alt="" /></p>
<ul>
<li>KusionStack 主页: <a href="https://kusionstack.io/">https://kusionstack.io/</a></li>
<li>仓库地址: <a href="https://github.com/KusionStack/kusion-in-action-book">https://github.com/KusionStack/kusion-in-action-book</a></li>
</ul>
<blockquote>
<p><strong>Note:</strong> 本地安装 <a href="https://github.com/rust-lang/mdBook/releases">mdbook</a> 二进制工具，后执行 <code>mdbook serve</code> 命令启动本地电子书服务，然后打开对应网址查看。</p>
</blockquote>
<hr />
<h2 id="版权"><a class="header" href="#版权">版权</a></h2>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">《KusionStack 实战》</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/KusionStack/kusion-in-action-book" property="cc:attributionName" rel="cc:attributionURL">KusionStack 团队</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>KusionStack 作为一个可编程技术栈(后文简称 Kusion)，其设计目标是为提升运维的效能，通过语言 +Konfig+ 工具 三位一体的手段突破手工运维的时效性限制，为云原生代码化的快速落地提供整条解决方案。</p>
<p>K8S 虽然是一个伟大的平台，但是因为作为平台系统的定位决定了不可能为各种业务场景提供完整的解决方案，这些缺失的拼图只能有用户和社区共建。比如 K8S 提供的时候比较原子化的操作，离真实的需要组合、批量等复杂操作的业务场景有一定的 Gap，这间接造成了云原生落地过程中模型编写困难、配置上线困难、以及线上问题定位困难能问题。</p>
<p>Kusion 尝试通过最大化的复用配置代码、通过通过 KCL 能力和抽象的 Konfig 减少用户接触的配置见面、通过区分不同的角色和功能将 K8S 的大量需要填空的配置变成带默认选项的选择题，从而简化复杂业务的配置编写。同时通过动态组合配置，实现统一套配置库为多集群、批量等环境、甚至不同的基础设施平台提供差异化支持。</p>
<p>当 Kusion 提供复杂配置描述能力之后，自然要面临复杂配置配套的更为复杂的操作支持。Kusion 通过 kusionctl 工具聚合了面向业务的高层次的工具，为配置的编写、测试、发布提供一站式支持，为配置代码变更上线提供了最短的路径。</p>
<p>作为复杂的软件系统，对于线上系统的诊断、定位和分析工具也是落地过程中必不可少的环节。使用者在提交变更后往往需要了解模型的调和步骤，逐步模型观察状态。为了使得用户更易于理解、上手，Kusion 提供对用户变更的模型及其关联模型的变更追踪、链路可视化、live 对比、关键资源可视化、异常定位等功能，帮助用户低成本玩转云原生实践。</p>
<p>天下武功，唯快不破！正因为 Kusion 提升了运维的效能，这使得应用在相同的可接受超时时间内可以做更多的事情，包含将更多的批量、复合的操作打包为事务的可能。通过事务的原子化语义，Kusion 用户可以用更简单的方式运维包装为事务的批量、分步等复杂的操作，从而为更高级的场景构建更多的可复用的配置积木。</p>
<p>本书希望通过一些可以实操的示例展示 Kusion 的用法和设计理念，为云原生代码化的快速落地贡献绵薄之力。透过 Kusion 看云，万物皆可配置，快乐运维不是梦。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-简介"><a class="header" href="#1-简介">1. 简介</a></h1>
<p>Kusion 是开源的可编程技术栈，由面向领域的 KCL 配置语言、Konfig 标准模型配置库、Kusion 状态引擎框架、配套的管理工具和 IDE 辅助插件等部分组成。本章我们简单介绍 Kusion 的设计思路和重要组件工具。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-背景"><a class="header" href="#11-背景">1.1 背景</a></h1>
<p>云计算从开始的物理机逐步发展到虚拟机和容器，目前云原生是云计算发展的新阶段。在云原生的变革过程中，软件的架构和使用的方式并没有大的变化。但是云原生时代容器和微服务的流行带来了服务数量级的增长，这对软件的开发、部署和运维模式都带来了新的挑战。</p>
<p>当后台系统从单机架构演变到基于 Kubernetes 平台的微服务架构，天然具备了平台提供的极致的弹性伸缩、故障的恢复等能力。但是定位是基础平台的 Kubernetes 主要实现了容器的调度和编排的能力，而对于企业用户的容器的监控、运维，包括 CI/CD 等定制性需求并没有提供原生的支持。虽然 Kubernetes 提供了灵活的扩展能力，但是不同企业不同的研发能力和投入差异，都为云原生的落地带来了各种挑战。</p>
<p>开源社区通过 kustomize、velocity 等技术组合临时缓解了 Kubernetes 平台的 Yaml 文件爆炸的问题，同时结合 GitOps 和代码评审等手段进一步提升了代码和工程质量，为云原生的运维发展方向提供了很好的实践参考。相比经典运维中台，目前这类技术手段的好处清晰明确，往往可以比较简单的搭建起来，不强依赖产品研发资源投入，但其工程视角缺点也非常明显。首先 Kubernetes API 的设计较为复杂，仅是 Kubernetes 原生提供的 low level API 就暴露了 500 多种模型，2000 多字段，场景上几乎涵盖了基础设施应用层的方方面面，即使是专业同学也很难理解所有细节。其次这种方式的工程化程度很低，违反 DRY 原则，违反各团队职责能力高内聚低耦合的原则。同时由于团队边界造成的多个割裂的平台，用户需在多个平台间切换，每个平台的操作方式各异，加上跳板机黑屏命令，都为运维的效率造成了很大影响。</p>
<p>以国内的蚂蚁集团为例：蚂蚁基础技术在过去几年通过 mesh 等技术手段将通用技术下层到基础平台，同时通过为集中式、标准化、低变更频率的应用提供统一的运维中台充分的拥抱了云原生技术，并获取了其带来的技术红利。随着云原生基础服务和标准化应用逐渐稳定后，对于非标准应用等个性化的需求的运维支持成了云原生落地所面临的主要矛盾。在典型案例中一个多应用的 infra 项目仍然维护了多达 5 万多行 YAML，即使在有一定的工具支持的情况下，完成一次完整的发布需要 2 天时间。如何结合 Kubernetes 生态的开放、可配置的特点，以自动的方式支持部署和运维非标应用是当前亟需解决的问题。</p>
<p>根据康威定律，一个良好的软件系统架构一定是反映了背后的组织架构运转模式。因此云原生落地中的各种困难其实是反映了背后经典运维手段不能适应微服务结构变化的问题。我们不能再以传统的过程式思维来运维海量的云原生应用，需要充分利用声明式思维方式描述系统终态，然后通过 Kubernetes 平台、终态的决策引擎和自定义的 operator 自动向描述的系统终态逼近。可以用一个家庭智能温控的例子做类比：我们只需要声明需要一个舒适的温度（声明一个终态），然后家庭智能系统（终态的决策引擎）据不同温度传感器的反馈决定向空调发出具体操作（自定义的 operator），当室内温度被外界因素干扰时家庭智能系统会自动即使调控到舒适的温度这个终态。SRE 也可以通过声明式描述系统终态、配合自动化终态调和引擎实现云原生规模化运维工作。</p>
<p>声明式描述终态是第一步，Kusion 项目尝试通过面相云原生运维场景定制的 KCL 声明式的配置语言、通用的基础模型 Konfig 库、KusionCtl 引擎和工具、再结合 IDE 插件来实现高效的 GieOps 代码化方式运维云原生的基础设施和应用。同时我们希望通过将 Kusion 完全开源的方式来为云原生的快速落地贡献绵薄之力。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-kcl-语言"><a class="header" href="#12-kcl-语言">1.2 KCL 语言</a></h1>
<p>KCL(Kusion Configuration Language)是 Kusion 内置的面相云原生领域配置语言。KCL 设计之初受 Python3 启发，同时吸收了声明式、OOP 编程范式的理念设计等设计，是一种专用于配置定义、校验的动态强类型的面相配置和策略场景的语言。本节我们将快速展示 KCL 语言的基本特性。</p>
<h2 id="121-hello-kcl"><a class="header" href="#121-hello-kcl">1.2.1 hello KCL</a></h2>
<p>学习新语言的最佳途径是自己亲手写几个小程序，配置语言也是如此。KCL 作为一种配置策略语言，我们可以像写配置一样写 KCL 程序。</p>
<p>下面是一个简单的 <code>hello.k</code> 程序：</p>
<pre><code class="language-python">hello = &quot;KCL&quot;
</code></pre>
<p>将 <code>hello</code> 属性设置为 <code>&quot;KCL&quot;</code> 字符串。然后将代码保存到 <code>hello.k</code> 文件中。</p>
<p>如何执行这个程序取决于具体的开发环境，我们先假设本地的 macOS 或者是 Linux 系统已经安装了 <code>kcl</code> 命令（或者通过 <code>docker run --rm -it kusionstack/kusion bash</code> 进入 Docker 环境测试）。然后在文件所在的目录命令行输入以下命令执行：</p>
<pre><code class="language-shell">$ kcl hello.k 
hello: KCL
</code></pre>
<p>命令行执行的效果如图所示：</p>
<p><img src="ch1-intro/../images/ch1.2-hello.gif" alt="" /></p>
<p>输出的是 YAML 格式的配置数据。这个程序虽然简单，但是我们可以通过执行 KCL 配置程序到输出结果验证了开发环境和 <code>kcl</code> 命令行的基本用法。</p>
<h2 id="122-再复杂一点的配置"><a class="header" href="#122-再复杂一点的配置">1.2.2 再复杂一点的配置</a></h2>
<p>常见的配置数据除了的普通的 key-value 对，还有嵌套的字典和列表类型，同时 value 基础类型除了字符串还有布尔和数值等类型。下面是更为复杂一点的 <code>server.k</code> 配置：</p>
<pre><code class="language-python"># This is a KCL document

title = &quot;KCL Example&quot;

owner = {
	name = &quot;The KCL Authors&quot;
	data = &quot;2020-01-02T03:04:05&quot;
}

database = {
	enabled = True
	ports = [ 8000, 8001, 8002 ]
	data = [ [&quot;delta&quot;, &quot;phi&quot;], [3.14] ]
	temp_targets = { cpu = 79.5, case = 72.0 }
}

servers = [
	{ip = &quot;10.0.0.1&quot;, role = &quot;frontend&quot;}
	{ip = &quot;10.0.0.2&quot;, role = &quot;backend&quot;}
]
</code></pre>
<p>其中 <code>#</code> 开头的表示行注释。<code>owner</code> 的 value 是一个字典，字典的面值通过 <code>{}</code> 方式包含的内容，字典内部的 key-value 和 <code>hello = &quot;KCL&quot;</code> 例子的写法类似。<code>database</code> 则是另一个字典，其中字典属性的 value 出现了布尔 <code>True</code>、列表 <code>[]</code> 和 <code>{}</code> 字典，其中列表和字典中还出现了数值类型的 value。 最后一个 <code>servers</code> 属性则是一个列表，列表内部嵌套着字典（字典和列表以及后续将要讲到的 <code>schema</code> 都可以相互嵌套）。</p>
<p>该配置输出的 YAML 结果如下：</p>
<pre><code class="language-yaml">$ kcl server.k 
title: KCL Example
owner:
  name: The KCL Authors
  data: '2020-01-02T03:04:05'
database:
  enabled: true
  ports:
  - 8000
  - 8001
  - 8002
  data:
  - - delta
    - phi
  - - 3.14
  temp_targets:
    cpu: 79.5
    case: 72.0
servers:
- ip: 10.0.0.1
  role: frontend
- ip: 10.0.0.2
  role: backend
</code></pre>
<h2 id="123-schema-定义配置的结构"><a class="header" href="#123-schema-定义配置的结构">1.2.3 schema 定义配置的结构</a></h2>
<p>KCL 通过 <code>schema</code> 语法结构为有着固定属性结构和默认值行为的属性提供抽象支持。</p>
<p>比如上面例子的中 <code>database</code> 的配置一般是用默认值即可。这样我们可以通过为数据库的默认配置定义一个结构：</p>
<pre><code class="language-python">schema DatabaseConfig:
    enabled: bool = True
    ports: [int] = [ 8000, 8001, 8002 ]
    data: [[str|float]] = [ [&quot;delta&quot;, &quot;phi&quot;], [3.14] ]
    temp_targets: {str:float} = { cpu = 79.5, case = 72.0 }
</code></pre>
<p><code>enabled</code> 是布尔类型；<code>ports</code> 为整数列表类型；<code>data</code> 为列表的列表，内层的列表元素是字符串或者浮点数类型；<code>temp_targets</code> 则是一个字典类型，字典的属性值是浮点数类型。并且 <code>DatabaseConfig</code> 的每个属性都定义了默认值。</p>
<p>然后通过 <code>database = DatabaseConfig{}</code> 就可以产生和默认值相同属性的结构。用户也可以修复默认值：</p>
<pre><code class="language-python">database = DatabaseConfig{
    ports = [2020, 2021]
}
</code></pre>
<p><code>schema DatabaseConfig</code> 不仅仅为属性提供了默认值，还为属性添加了类型信息。因此，如果用户不小心写错属性值类型的话，KCL 将会给出友好的错误提示，比如下面的例子将 <code>ports</code> 错误地写成了浮点数类型：</p>
<pre><code class="language-python">database = DatabaseConfig{
    ports = [1.2, 1.3]
}
</code></pre>
<p>执行时将产生类似以下的错误（显示的文件路径和本地环境有关）：</p>
<pre><code class="language-shell">$ kcl server.k 
KCL Compile Error[E2G22] : The type got is inconsistent with the type expected
    ---&gt; File /path/to/server.k:8:2
    8 |    ports = [1.2, 1.3]
      5    ^  -&gt; got [float(1.2)|float(1.3)]
    ---&gt; File /path/to/server.k:3:2
    3 |    ports: [int] = [ 8000, 8001, 8002 ]
      5    ~  -&gt; expect [int]
expect [int], got [float(1.2)|float(1.3)]
</code></pre>
<p>类似地我们可以用以下的代码封装 <code>servers</code> 部分的属性：</p>
<pre><code class="language-python">schema ServerConfig:
	ip: str
	role: &quot;frontend&quot; | &quot;backend&quot;

servers = [
	ServerConfig{ip = &quot;10.0.0.1&quot;, role = &quot;frontend&quot;}
	ServerConfig{ip = &quot;10.0.0.2&quot;, role = &quot;backend&quot;}
]
</code></pre>
<p>其中 <code>ServerConfig</code> 的 <code>ip</code> 是字符串类型，并没有给出默认值。用户在生成 <code>ServerConfig</code> 类型的属性时必须手工添加 <code>ip</code> 属性的值，否则 KCL 将会报出缺少必填属性的错误。<code>role</code> 属性是 <code>&quot;frontend&quot; | &quot;backend&quot;</code> 枚举字符串类型。</p>
<p>此外，<code>schema</code> 还可以结合 可选属性、<code>check</code>、<code>mixin</code>、继承和扩展模块实现更为复杂的配置和策略数据的抽象，细节可以参考手册部分的文档。</p>
<h2 id="124-playgound"><a class="header" href="#124-playgound">1.2.4 Playgound</a></h2>
<p>如果本地安装了 KCL 工具，可以通过 <code>kcl-go play</code> 启动一个 Playgound：</p>
<pre><code class="language-shell">$ kcl-go play
listen at http://127.0.0.1:2021
...
</code></pre>
<p>该命令会自动在浏览器打开 Playgound 页面，如下图所示：</p>
<p><img src="ch1-intro/../images/ch1.2-playground.jpg" alt="" /></p>
<p>代码通过 <code>import</code> 展示了如何导入一个扩展模块，同时展示了基本的 <code>schema</code> 用法。</p>
<p>Playgound 提供了基本的执行功能，同时对代码提供了语法高亮和格式化的功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-konfig-模型库"><a class="header" href="#13-konfig-模型库">1.3 Konfig 模型库</a></h1>
<p>Konfig 是 Kusion 内置的基础配置模型库（ Kuison+config 的组合词）。本节将展示如何通过 KCL 语言为已有的 YAML 配置建模，从而构建一个自己的模型库——这也是 Konfig 的雏形。最后简单介绍 Konfig 诞生的背景。</p>
<h2 id="131-yaml-建模"><a class="header" href="#131-yaml-建模">1.3.1 YAML 建模</a></h2>
<p>YAML 是用来写配置文件的语言，非常简洁和强大，目前是 Kubernetes 官方钦定的首选配置交换格式。YAML 很灵活也很好写，同时也很容易出错！比如 Kubernetes 官网的 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Nginx-Deployment</a> 例子：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    spec:
      containers:
      - image: nginx:1.14.2
        name: nginx
        ports:
        - containerPort: 80
</code></pre>
<p>该例子部署一个 Nginx 服务。如果我们不小心写错其中的某个配置，并且不能在第一时间发现，那么可能带来未知的风险。其实对于 Kubernetes 语境来说，这个 <code>Deployment</code> 配置是有着明确的定义的：每个字段的名字和类型、以及相关字段的值需要满足一定的规则等。通过定制面向领域的 DSL 语言来提升配置的安全性正是设计 KCL 语言的初衷。</p>
<p>我们可以尝试用 KCL 给 <code>Deployment</code> 配置建模：</p>
<pre><code class="language-py">schema Deployment:
    final apiVersion: str = &quot;apps/v1&quot;
    final kind: str = &quot;Deployment&quot;

    metadata?: apis_ObjectMeta
    spec?: DeploymentSpec
</code></pre>
<p>我们首选通过 KCL 的 <code>schema</code> 关键字定义一个 <code>Deployment</code> 模型。其中的 <code>apiVersion</code> 和 <code>kind</code> 字段有着固定的类型和值，因此我们通过 <code>final</code> 和默认值的特性描述。而对于复杂的 <code>metadata</code> 和 <code>spec</code> 字段则通过新的 <code>ObjectMeta</code> 和 <code>DeploymentSpec</code> 模型描述，它们的字段名均已问号结尾表示是可选的字段。</p>
<p><code>ObjectMeta</code> 模型的全部属性有很多，目前只定义需要的部分如下：</p>
<pre><code class="language-py">schema ObjectMeta:
    name?: str
    namespace?: str
</code></pre>
<p>同样 <code>DeploymentSpec</code> 模型的定义如下：</p>
<pre><code class="language-py">schema DeploymentSpec:
    replicas?: int
    selector: LabelSelector
    template: PodTemplateSpec
</code></pre>
<p>其中 <code>replicas</code> 是一个可选字段，<code>selector</code> 和 <code>template</code> 字段则继续用新模型描述。</p>
<p><code>LabelSelector</code> 模型用户描述 Label 选择的参数，定义如下：</p>
<pre><code class="language-py">schema LabelSelector:
    matchLabels?: {str:str}
</code></pre>
<p>其中 <code>matchLabels</code> 字段是一个 dict 字典类型，字典的 Key 和 Value 都是字符串。</p>
<p><code>PodTemplateSpec</code> 模型定义如下：</p>
<pre><code class="language-py">schema PodTemplateSpec:
    metadata?: ObjectMeta
    spec?: PodSpec

schema PodSpec:
    containers: [Container]

schema Container:
    image?: str
    name: str
    ports?: [ContainerPort]

schema ContainerPort:
    containerPort: int

</code></pre>
<p>其中 <code>metadata</code> 字段用的是已经定义的 <code>ObjectMeta</code> 类型，<code>spec</code> 字段则通过 <code>PodSpec</code> 和 <code>Container</code> 描述其中容器的镜像和名称，<code>ports</code> 通过 <code>ContainerPort</code> 类型描述。</p>
<h2 id="132-基于模型库重写配置"><a class="header" href="#132-基于模型库重写配置">1.3.2 基于模型库重写配置</a></h2>
<p>现在我们可以将以上代码合并保持到 <code>apps/deployment.k</code> 文件中作为一个自定义的模型库，这就是第一版 Konfig 雏形了（Konfig 开源模型库在 <code>base.pkg.kusion_kubernetes.api.apps.v1</code> 也提供了更完整的 <code>Deployment</code> 模型定义）。</p>
<p>现在可以创建 <code>main.k</code>，基于这个 <code>Deployment</code> 模型重新构造配置：</p>
<pre><code class="language-py">import apps

demo = apps.Deployment {
    metadata.name = &quot;nginx-deployment&quot;
    spec = {
        replicas = 3
        selector.matchLabels = {
            app = &quot;nginx&quot;
        }
        template.spec.containers = [
            {
                name = &quot;nginx&quot;
                image = &quot;nginx:1.14.2&quot;
                ports = [
                    {containerPort = 80}
                ]
            }
        ]
    }
}
</code></pre>
<p>现在输入的 KCL 配置代码虽然和原来的 YAML 文件差不多，但是获得了 Konfig 模型库提供的静态化类型和运行时校验规则的能力，同时可以配合 IDE 插件获得更好的编码效率，也可以让我们写的配置代码更安全。然后通过 <code>kcl main.k</code> 命令可以将模型渲染出之前的 YAML 文件了。</p>
<h2 id="133-konfig-诞生的背景"><a class="header" href="#133-konfig-诞生的背景">1.3.3 Konfig 诞生的背景</a></h2>
<p>从本节的例子可以发现，相对于我们的业务配置代码，底层模型的抽象代码更多。真实 Konfig 模型库中的 <code>Deployment</code> 代码更加庞大，同时也提供了更加完整灵活的静态类型和规则检查保障。Konfig 最初朴素的出发点就是改善 YAML 用户的效率和体验，我们希望通过将代码更繁杂的模型抽象封装到统一的模型库中，从而简化用户侧配置代码的编写。</p>
<p>Konfig 的前身是蚂蚁在落地 IaC&amp;GitOps 的过程中采用的是 Konfig 大库。蚂蚁开始就把所有的 IaC 配置代码维护在一个统一的 Konfig 大仓库中，代码包括基础配置代码和业务配置代码两部分。之所以用一个大的仓库管理全部的 IaC 配置代码，是由于蚂蚁内部不同代码包的研发主体不同，会引发出包管理和版本管理的问题，从而导致平台侧需要支持类似编译平台的能力。采用大库模式下，业务配置代码、基础配置代码在一个大库中，因此代码间的版本依赖管理比较简单，平台侧处理也比较简单，定位唯一代码库的目录及文件即可，代码互通，统一管理，便于查找、修改、维护（大库模式也是 Google 等头部互联网公司内部实践的模式）。</p>
<p>大库模式虽然有版本管理简单等优点，但是缺点也非常多：比如大库导致仓库体积爆炸的问题会给网络下载带来更大的压力，因此不适合开源社区的分布式、异步协作的开发模式。因此当 Kusion 项目绝对开源后，我们对 Konfig 大库做了大量改造和拆分工作，核心目标是将和 Kubernetes 相关的基础模型保留，将和蚂蚁内部业务耦合比较紧密的业务代码剥离（业务相关部分的最佳实践方式会在案例实践场景中体现）。因此开源版本的 Konfig 库可以看作是 Kusion 项目针对 Kubernetes 云原生的开放生态提供基础设施模型库，这样可以帮助用户以较少的配置代码部署和运维 Kubernetes 生态的应用。同时我们希望和社区共建的方式完善和改进 Kubernetes 生态的基础设施模型库。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-kusion-用户界面"><a class="header" href="#14-kusion-用户界面">1.4 Kusion 用户界面</a></h1>
<p>Kusion 一词来源于 fusion（意为融合） + kubernetes，是基于云原生基础设施，通过定义云原生可编程接入层，提供包括配置语言、模型界面、自动化工具、最佳实践在内的一整套解决方案，连通云原生基础设施与业务应用，连接定义和使用基础设施的各个团队，串联应用生命周期的研发、测试、集成、发布各个阶段，服务于云原生自动化系统建设，加速云原生落地。Kusion 引擎的终极目标是为了解决自动化运维：SRE 只是通过 KCL 语言 +Konfig 大库描述自己的业务终态，Kusion 引擎通过实时监控系统状态根据描述的状态响应规则进行运维操作。上层用户通过 Kusion 用户界面和 Kusion 引擎交互。</p>
<h2 id="141-单-app-应用界面"><a class="header" href="#141-单-app-应用界面">1.4.1 单 App 应用界面</a></h2>
<p>Kusion 用户界面并不是仅仅指传统的网页控制台界面，它是用户在使用 Kusion 过程中直接感知的能力和功能界面。最简单的 Kusion 用户界面就是 <a href="https://kusionstack.io/docs/user_docs/support/faq-concepts#5-kusionctl">KusionCtl</a> 命令行工具。</p>
<p><img src="ch1-intro/../images/ch1.4-kusion-user-interface-01.png" alt="" /></p>
<p>以上只是针对单 App 应用这种简单场景的关系图，用户只面对一个 Kusion 命令行工具。</p>
<h2 id="142-规模化-app-应用界面"><a class="header" href="#142-规模化-app-应用界面">1.4.2 规模化 App 应用界面</a></h2>
<p>Kusion 最初是针对规模化 App 应用运维而开发的可编程配置技术栈。为了开发效率，Kusion 同时为 kusionctl 命令行提供了配套和的提效工具：KCL 命令、DevOps 工具、IDE 插件等。此外为了和开发系统集成，Kusion 同时也可针对 Github Action、Gitlab Action 和 ArgoCD 等系统配置对应的能力。因此更详细的 Kusion 用户界面如下图所示：</p>
<p><img src="ch1-intro/../images/ch1.4-kusion-user-interface-02.png" alt="" /></p>
<p>现在 Kusion 用户界面对应其中向左倒下的大写 L 形状的界面，包含本地工具和各种 CICD 集成的界面等。</p>
<h2 id="143-不同角色和场景组合"><a class="header" href="#143-不同角色和场景组合">1.4.3 不同角色和场景组合</a></h2>
<p>在规模化运维中，经常需要涉及 App 和基础设施两个不同的应用场景，同时涉及开发者和 SRE 两种不同的角色，两种角色和两种场景产生的多种组合。不同角色的用户针对不同的场景分别开发 App Ops Config 和 Infra Ops Config，并统一到 Konfig 大库中进行开发和版本管理。这些配置最终构成了规模化运维涉及到各种配置代码，它们通过 Kusion 用户界面开发、测试，并最终通过各种 CICD 系统自动化 Apply 到最终目标平台。</p>
<h2 id="144-本地工具和生态集成"><a class="header" href="#144-本地工具和生态集成">1.4.4 本地工具和生态集成</a></h2>
<p>KCL 命令行工具、DevOps 工具和 IDE 插件等本地工具用于提供原子的能力，同时方便本地开发工作。开发完成之后通过 Konfig 大库合并代码时触发各种 CICD 系统自动化 Apply 到最终目标平台。</p>
<!--
自动化运维的关键是从配置到线上服务再到配置形成闭合的反馈线路，在ArgoCD系统中通过接入KusionSrv服务就可以实现对配置仓库到自动化修改（KCL语言的能力不仅仅提供配置，同时也可以将配置仓库作为元数据库进行增删改查）。在ArgoCD系统Kusion引擎的反馈流程如下图：

![](../images/ch1.5-kusion-01.png)

不过目前Kusion的引擎还在建设阶段，我们平时提到 Kusion，一般是对这一整套解决方案的统称；而 Kusion 生态工具链则包含了kcl命令行工具、KusionCtl命令行工具、KCL IDE插件等贯穿 Kusion 解决方案各个部分的自动化工具。目前Kusion引擎还工作在半自动化阶段，如下图所示：

![](../images/ch1.5-kusion-02.jpg)

上层的SRE用户通过Kusion提供的Konfig模型库描述终态，通过KusionCtl命令行工具进行diff仓库和线上系统差异，然后通过脚本进行半自动化运维工作。通过结合最佳的实践和CICD系统提供的辅助能力到KusionCtl命令，我们可以极大简化多集群集成、权限系统集成、风险系统集成等系统化运维等工作。这类只是对Kusion引擎设计思路的简要介绍，我们将在第3章详细介绍Kusion等整体架构和底层引擎的工作细节。
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-ide-插件"><a class="header" href="#15-ide-插件">1.5 IDE 插件</a></h1>
<p>为了提高 IDE 开发 KCL 的效率，Kusion 为 VS Code 在线版和本地版本提供了插件支持。在线版本可以从 <a href="https://vscode.dev">https://vscode.dev</a> 地址打开，然后安装“KCL for vscode.dev 插件”，效果如下:</p>
<p><img src="ch1-intro/../images/ch1.5-ide-vscode.png" alt="" /></p>
<p>本地 VS Code 可以安装完整的 <a href="https://marketplace.visualstudio.com/items?itemName=kcl.kcl-vscode-extension">KCL 插件</a>，提供了高亮、自动补全（部分：关键字补全等）、跳转、悬停、大纲等功能。插件虽然不是 Kusion 必须的部分，但是可以提高效率推荐安装。</p>
<!--


KCL 生态系统为常用的编辑器提供了插件，帮助用户更加高效和无缝地进行 KCL 的开发。可选的平台有：

Visual Studio Code：KCL 扩展，提供对 KCL 编程语言的支持（重点维护中）

IntelliJ IDEA：KCL 插件，提供对 KCL 编程语言的支持

vim：计划中

## 1.5.1 Visual Studio Code 插件

### 1.5.1.1 插件安装

环境要求：VS Code 1.54+

安装：Extension -> 查询 "KCL" -> 安装，如图：

![](../images/ch1.5-vscode-install.gif)

### 1.5.1.2 插件功能

高亮、自动补全（部分：关键字补全等）、跳转、悬停、大纲：

![](../images/ch1.5-vscode-feature.gif)

## 1.5.2 Intellij IDEA 插件

### 1.5.2.1 插件安装

环境要求：Intellij IDEA 2020.2+

安装：Intellij IDEA -> Preference -> plugins -> 查找 “KCL”：todo：示意gif（暂不支持从插件市场安装）

### 1.5.2.2 插件功能

高亮、自动补全（部分：导入路径的补全、关键字补全）、跳转、大纲：todo 示意 gif

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-你好-kusion"><a class="header" href="#2-你好-kusion">2. 你好 Kusion</a></h1>
<p>本章以 Kubernetes 官方的 <a href="https://github.com/kubernetes/examples/blob/master/guestbook/frontend-deployment.yaml">Guestbook</a> 为例子，展示 Kusion 工具对接 Kubernetes 的用法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-初始化工程"><a class="header" href="#21-初始化工程">2.1 初始化工程</a></h1>
<p>在开始前用户需要先配置好 <a href="https://kusionstack.io/docs/user_docs/getting-started/install">Kusion 工具</a> 和 <a href="https://github.com/KusionStack/konfig">Konfig 配置库</a>。初始化工程是在 Konfig 配置库内添加代码。</p>
<h2 id="211-执行-init-命令"><a class="header" href="#211-执行-init-命令">2.1.1 执行 <code>init</code> 命令</a></h2>
<p>第一步：进入 <code>Konfig/appops</code> 目录对应的命令行，输入 <code>kusion init</code> 命令初始化工程：</p>
<pre><code>$ kusion init
Use the arrow keys to navigate: ↓ ↑ → ← 
? This command will initialize KCL file structure and base codes for a new project.Please choose a KCL schema type: 
  ▸ Server
</code></pre>
<p>选择工程的类型：目前只有一个 Server 类型，点击回车确定。然后输入工程的名字：</p>
<pre><code>Use the arrow keys to navigate: ↓ ↑ → ← 
✔ Server
✔ project name: █emo
</code></pre>
<p>比如输入 <code>demo</code> 的名字然后回车确认。然后输入 stack 的名字（stack 是为了方便管理大量云原生应用而人为做的分类）：</p>
<pre><code>Use the arrow keys to navigate: ↓ ↑ → ← 
✔ Server
project name: demo
stack name: █ev
</code></pre>
<p>然后选择默认集群的名字：</p>
<pre><code>Use the arrow keys to navigate: ↓ ↑ → ← 
✔ Server
project name: demo
stack name: dev
✔ cluster name: █efault
cluster name: █efault
</code></pre>
<p>然后指定镜像：</p>
<pre><code>Use the arrow keys to navigate: ↓ ↑ → ← 
✔ Server
project name: demo
stack name: dev
✔ cluster name: █efault
✔ image: █cr.io/google-samples/gb-frontend:v4
</code></pre>
<p>初始化完成后会产生一个 demo 目录，其中内容如下：</p>
<pre><code>$ cd demo
$ tree .
.
├── README.md
├── base
│   └── base.k
├── dev
│   ├── ci-test
│   │   └── settings.yaml
│   ├── kcl.yaml
│   ├── main.k
│   └── stack.yaml
└── project.yaml

3 directories, 7 files
</code></pre>
<p>现在我们已经有一个完整的 Kusion 配置项目。</p>
<h2 id="212-理解代码内容"><a class="header" href="#212-理解代码内容">2.1.2 理解代码内容</a></h2>
<p>查看 base 目录的基线配置，其中 <code>base/base.k</code> 内容如下：</p>
<pre><code class="language-python">import base.pkg.kusion_models.kube.frontend
import base.pkg.kusion_models.kube.frontend.container
import base.pkg.kusion_models.kube.templates.resource as res_tpl
import base.pkg.kusion_models.kube.frontend.service

# Application Configuration
appConfiguration: frontend.Server {
    # Main Container Configuration
    mainContainer = container.Main {
        name = &quot;php-redis&quot;
        env = [
            {
                name = &quot;GET_HOSTS_FROM&quot;
                value = &quot;dns&quot;
            }
        ]
        ports = [{containerPort = 80}]
    }
    selector = {
        &quot;tier&quot; = &quot;frontend&quot;
    }
    podMetadata.labels: {
        &quot;tier&quot; = &quot;frontend&quot;
    }
    schedulingStrategy.resource = res_tpl.medium
    services = [
        service.Service {
            name = &quot;frontend-service&quot;
            type = &quot;NodePort&quot;
            ports = [{port = 80}]
        }
    ]
}
</code></pre>
<p>其中包含主容器和应用的默认配置。基线配置参数相对相对，不过都是默认的配置，平时不需要经常修改。</p>
<p><code>dev</code> 对应 stack 类型（常见的类型还有 gray 表示灰度、pre 表示预发、prod 表示正是版本等），这里表示开发状态的配置。 配置的入口在 <code>dev/main.k</code> 文件：</p>
<pre><code class="language-python">import base.pkg.kusion_models.kube.frontend
import base.pkg.kusion_models.kube.templates.resource as res_tpl

# The application configuration in stack will overwrite 
# the configuration with the same attribute in base.
appConfiguration: frontend.Server {
    image = &quot;gcr.io/google-samples/gb-frontend:v4&quot;
    schedulingStrategy.resource = res_tpl.tiny
}
</code></pre>
<p><code>main.k</code> 中只需要填写和基线参数不一样的部分。比如 image 在基线的基础之后增加新的镜像路径，<code>schedulingStrategy.resource</code> 则是覆盖已有的基线配置。</p>
<p>另外，<code>project.yaml</code> 中记录了工程的名字 demo，<code>dev/stack.yaml</code> 中记录了当前目录的类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-apply-子命令"><a class="header" href="#22-apply-子命令">2.2 Apply 子命令</a></h1>
<p><code>kusion</code> 提供了一个 <code>apply</code> 子命令将当前 stack 中的一系列资源应用到运行时，它会根据 Konfig 堆栈中的 KCL 文件创建或更新或删除资源。 正如 <code>kubectl apply</code> 和 <code>terraform apply</code> 等子命令一样，对于基于声明式接口的系统 Apply 子命令通常用于生效配置操作，它也是 Kusion 的核心功能。本节展示 <code>kusion apply</code> 子命令的基本用法。</p>
<h2 id="221-查看-apply-子命令帮助"><a class="header" href="#221-查看-apply-子命令帮助">2.2.1 查看 apply 子命令帮助</a></h2>
<p>Kusion 默认会生成执行计划，并最终交给用户确认执行。首先查看 <code>apply</code> 命令的帮助信息：</p>
<pre><code class="language-shell">$ kusion apply -h
Apply a series of resource changes within the stack.

 Create or update or delete resources according to the KCL files within a Konfig stack. By default, Kusion will generate
an execution plan and present it for your approval before taking any action.

 You can check the plan details and then decide if the actions should be taken or aborted.

Examples:
  # Apply with specifying work directory
  kusion apply -w /path/to/workdir
  
  # Apply with specifying arguments
  kusion apply -D name=test -D age=18
  
  # Apply with specifying setting file
  kusion apply -Y settings.yaml
  
  # Skip interactive approval of plan details before applying
  kusion apply --yes

Options:
  -D, --argument=[]: Specify the arguments to apply KCL. Example: kusion apply -D name=test -D age=18 | kusion apply
--argument name=test,age=18
  -d, --detail=false: Automatically show plan details after previewing it
      --operator='': Specify the operator. Example: kusion apply -operator dayuan.ldy
  -O, --overrides=[]: Specify the configuration override path and value
  -Y, --setting=[]: Specify the command line setting files. Example: kusion apply -Y settings.yaml
  -w, --workdir='': Specify the work directory.
  -y, --yes=false: Automatically approve and perform the update after previewing it

Usage:
  kusion apply [flags] [options]

Use &quot;kusion apply options&quot; for a list of global command-line options (applies to all commands).
</code></pre>
<h2 id="222-通过-apply-命令查看变更信息"><a class="header" href="#222-通过-apply-命令查看变更信息">2.2.2 通过 <code>apply</code> 命令查看变更信息</a></h2>
<p>在 <code>demo/dev</code> 目录下输入 <code>kusion apply</code> 命令查看执行计划：</p>
<pre><code class="language-shell">$ kusion apply
 SUCCESS  Compiling in stack dev...

Stack: dev    Provider                Type              Name    Plan
      * ├─  kubernetes        v1:Namespace              demo  Create
      * ├─  kubernetes  apps/v1:Deployment           demodev  Create
      * └─  kubernetes          v1:Service  frontend-service  Create

Use the arrow keys to navigate: ↓ ↑ → ← 
? Do you want to apply these diffs?: 
  ▸ yes
    no
    details
</code></pre>
<p>在执行之前先切换到 <code>details</code> 选项回车查看详细信息：</p>
<pre><code>✔ details
Use the arrow keys to navigate: ↓ ↑ → ← 
? Which diff detail do you want to see?: 
  ▸ all
    &lt;kubernetes, v1:Namespace, demo&gt; Create
    &lt;kubernetes, v1:Service, frontend-service&gt; Create
    &lt;kubernetes, apps/v1:Deployment, demodev&gt; Create
    cancel
</code></pre>
<p>可以查看新建的 Namespace、Service、Deployment 等资源。切换到 <code>all</code> 选项回车查看全部差异：</p>
<pre><code>✔ details
✔ all

Provider: kubernetes
Type: apps/v1:Deployment
Name: demodev
Plan: Create
Diff: 
(root level)
± type change from &lt;nil&gt; to map
  - &lt;nil&gt;
  + id: 
    status: 
    attributes:
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: demodev
        namespace: demo
      spec:
        replicas: 1
        selector:
          matchLabels:
            app.kubernetes.io/env: dev
            app.kubernetes.io/instance: demo-dev
            app.kubernetes.io/name: demo
            cluster.x-k8s.io/cluster-name: default
            tier: frontend
        template:
          metadata:
            labels:
              app.kubernetes.io/env: dev
              app.kubernetes.io/instance: demo-dev
              app.kubernetes.io/name: demo
              cluster.x-k8s.io/cluster-name: default
              tier: frontend
          spec:
            containers:
            - env:
              - name: GET_HOSTS_FROM
                value: dns
              - name: APP_NAME
                value: demo
              - name: ENVIRONMENT
                value: dev
              - name: INSTANCE
                value: demo-dev
              - name: CLUSTER
                value: default
              image: gcr.io/google-samples/gb-frontend:v4
              name: php-redis
              ports:
              - containerPort: 80
                protocol: TCP
              resources:
                limits:
                  cpu: 100m
                  ephemeral-storage: 1Gi
                  memory: 100Mi
                requests:
                  cpu: 100m
                  ephemeral-storage: 1Gi
                  memory: 100Mi
    private: {}
    dependsOn: []

Provider: kubernetes
Type: v1:Namespace
Name: demo
Plan: Create
Diff: 
(root level)
± type change from &lt;nil&gt; to map
  - &lt;nil&gt;
  + id: 
    status: 
    attributes:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: demo
    private: {}
    dependsOn: []

Provider: kubernetes
Type: v1:Service
Name: frontend-service
Plan: Create
Diff: 
(root level)
± type change from &lt;nil&gt; to map
  - &lt;nil&gt;
  + id: 
    status: 
    attributes:
      apiVersion: v1
      kind: Service
      metadata:
        name: frontend-service
        namespace: demo
      spec:
        ports:
        - port: 80
        selector:
          app.kubernetes.io/env: dev
          app.kubernetes.io/instance: demo-dev
          app.kubernetes.io/name: demo
          cluster.x-k8s.io/cluster-name: default
          tier: frontend
        type: NodePort
    private: {}
    dependsOn: []
</code></pre>
<h2 id="223-通过-apply-命令执行变更计划"><a class="header" href="#223-通过-apply-命令执行变更计划">2.2.3 通过 <code>apply</code> 命令执行变更计划</a></h2>
<p>在执行变更计划前需要确保本地可以链接到 Kubernetes 集群，如果是本地测试可以选择启动 Docker 自带的 Kubernetes 集群。</p>
<p>在 dev 目录下执行 <code>kusion apply</code> 命令，然后选择 yes 执行计划：</p>
<pre><code>$ $ kusion apply
 SUCCESS  Compiling in stack dev...                                                                                                                        

Stack: dev    Provider                Type              Name    Plan
      * ├─  kubernetes        v1:Namespace              demo  Create
      * ├─  kubernetes  apps/v1:Deployment           demodev  Create
      * └─  kubernetes          v1:Service  frontend-service  Create

✔ yes
Start applying diffs......
 SUCCESS  Creating Namespace/demo
 SUCCESS  Creating Deployment/demodev
 SUCCESS  Creating Service/frontend-service
Creating Service/frontend-service [3/3] ██████████████████ 100% | 0s

Apply complete! Resources: 3 created, 0 updated, 0 deleted.
</code></pre>
<p>成功启动服务。</p>
<h2 id="224-查看服务信息"><a class="header" href="#224-查看服务信息">2.2.4 查看服务信息</a></h2>
<p><code>kusion apply</code> 命令启动的服务在 demo 名字空间下，也就是执行 <code>kusion init</code> 命令时指定的参数，保存在 <code>demo/project.yaml</code> 文件中。</p>
<p>我们可以通过 Kubernetes 自带的 kubectl 命令查看下产生了哪些 deploy：</p>
<pre><code>$ kubectl get --namespace demo deploy
NAME      READY   UP-TO-DATE   AVAILABLE   AGE
demodev   1/1     1            1           12m
</code></pre>
<p>查看有哪些 pods：</p>
<pre><code>$ kubectl get --namespace demo pods
NAME                       READY   STATUS    RESTARTS   AGE
demodev-6c85bfcc89-w67ns   1/1     Running   0          6m45s
</code></pre>
<p>查看有哪些 service：</p>
<pre><code>$ kubectl get --namespace demo service
NAME               TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
frontend-service   NodePort   10.0.0.1         &lt;none&gt;        80:30083/TCP   10m
</code></pre>
<p>服务已经绑定到了宿主机器的 30083 端口，可以在浏览器打开 http://localhost:30083 查看：</p>
<p><img src="ch2-hello-kusion/../images/ch2.2-guestbook.png" alt="" /></p>
<p>说明服务已经正常启动。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-kusion-核心概念"><a class="header" href="#3-kusion-核心概念">3. Kusion 核心概念</a></h1>
<p>本章尝试解释 Kusion 可编程配置技术栈背后的架构和概念。其中用户界面展示了 Kusion 技术栈用户使用界面，Project &amp; Stack 介绍了 Kusion 推荐的项目组织结构，State &amp; Backends 则介绍了 Kusion 背后的状态管理和厚度存储设计。最后介绍了 Kusion 架构和 KCL 语言的特色和设计思路。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-kusion-架构图"><a class="header" href="#31-kusion-架构图">3.1 Kusion 架构图</a></h1>
<p>本节介绍 Kusion 架构图，架构图本质上反应的是 Kusion 的工作流程和工作机制。熟悉了整体架构图之后，同样能够做到纲举目张为 Kusion 的日常使用提供指导。</p>
<h2 id="311-架构简图"><a class="header" href="#311-架构简图">3.1.1 架构简图</a></h2>
<p>先从架构简图开始，其中涉及 App 和基础设施如何通过 Kusion 技术栈联通目标平台。如下图所示：</p>
<p><img src="ch3-internal/../images/ch3.1-iac-arch-01.png" alt="" /></p>
<p>App 和 Infra 的开发人员完整最基础的功能和配置开发，SRE 则基于基础的功能通过完成运维配置代码化工作，然后通过 Kusion 技术栈将运维配置代码转化为不同目标平台的具体操作。</p>
<h2 id="312-架构大图"><a class="header" href="#312-架构大图">3.1.2 架构大图</a></h2>
<p>在架构简图的之上，将 Kusion 面对的具体场景和特性填充到各个子模块中的得到了架构大图：</p>
<p><img src="ch3-internal/../images/ch3.1-iac-arch-all.png" alt="" /></p>
<p>上层对应 App 和基层设施的不同场景，底层对接不同的云平台，中间是 Kusion 技术栈本身的组成。Kusion 可编程协议栈内部又分为用户界面、核心能力、配置语言等部分。其中用户界面主要面试上层的云原生应用的用户，通过 Kusion 提供的 Konfig 大库自动集成 Pipeline、Operation 操作界面、VSCode 的插件和相关的命令行工具等，和内部的 Konfig 模型库、IaC 引擎和 Kusion 服务等进行能力对接。最下面的是 KCL 配置策略语言，以及和 KCL 语言相关的语言插件、其他高级语言的 SDK 和其他 OpenAPI 风格的配置数据对接等，语言和协议层为上面的 Konfig 大库提供编程能力、为 IaC 引擎提供可被编程的 SDK 能力等。</p>
<!--
TODO: 再针对每块展开解释。
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-project--stack"><a class="header" href="#32-project--stack">3.2 Project &amp; Stack</a></h1>
<p>为了应对规模化运维面临的配置、团队多维度爆炸的挑战，Kusion 采用业界通用的思路通过引入 Project &amp; Stack 一层抽象来规范和简化化配置代码的管理。本节介绍 Project &amp; Stack 基本概念。</p>
<h2 id="321-project--stack-概念图"><a class="header" href="#321-project--stack-概念图">3.2.1 Project &amp; Stack 概念图</a></h2>
<p>Project &amp; Stack 是 Kusion 抽象的项目组织结构，项目采用 Project 概念抽象，其中对应多个 Stack 为可以独立部署、单独配置的最小 KCL 程序单元。二者关系如下图：</p>
<p><img src="ch3-internal/../images/ch3.2-project-stack.png" alt="" /></p>
<p>其中的 Base 比较特殊，对应 Project 中通用的基线配置，用于不同的 Stack 共享（并非独立部署单元）。</p>
<h2 id="322-project"><a class="header" href="#322-project">3.2.2 Project</a></h2>
<p>任何一个直接包含 project.yaml 的文件夹被称为一个 Project，project.yaml 用于说明该 project 的元数据信息。一个 Project 由一个或多个互相关联的 Stack 组成。Project 往往具有明确的业务语意，用户可以把一个应用映射成一个 Project，也可以把一种运维场景映射为一个 Project，比如建站运维等。一个 Project 必然属于一个租户。</p>
<h2 id="323-stack"><a class="header" href="#323-stack">3.2.3 Stack</a></h2>
<p>Stack 是一组可以独立部署、单独配置的 KCL 程序，是可以部署为一组基础设施实体的最小配置单元。一个 Stack 的所有专用配置文件需要位于同一文件夹内，该文件夹需要位于其所属 Project 的路径下，并且直接包含 stack.yaml。stack.yaml 用于说明该 Stack 的元数据信息，并且可以作为识别一个 Stack 的标识。Stack 往往表示 CI/CD 流程中的不同阶段，如 dev、gray、prod 等，或者表示一个大项目中不同的小项目。Kusion 提供 Stack 级别的权限控制。</p>
<h2 id="324-project-和-stack-的关系"><a class="header" href="#324-project-和-stack-的关系">3.2.4 Project 和 Stack 的关系</a></h2>
<p>一个 Project 包含一个或多个 Stack，而一个 Stack 必须属于一个 Project 并且只能属于一个 Project。用户可以根据自身需求解释 Project 和 Stack 的含义，灵活地组织两者之间的结构和关系。在跨团队协作、云原生的场景下，我们提供了如下 3 种 Project 和 Stack 关系组织的最佳实践：</p>
<ol>
<li>Enviroment 模式：Project 以一个整体存在，Stack 表示 Project 的不同环境，比如 dev、pre 和 prod 等，这些环境通常与 CI/CD 流程中的不同阶段相对应。Stack 具有 Project 需要的全部配置，只是对应部署的环境不同。</li>
<li>Micro-Project 模式：与微服务类似，Project 由多个较小的 Project 组成，比如一个 Project 需要的基础设施可能包括 Kubernetes 对象、数据库实体、监控实体等，这些基础设施实体均可作为一个较小的 Project 进行单独配置。我们将这些的较小的 Project 称为 Micro-Project，并通过 Stack 进行表示。Stack 仅具有 Project 需要的部分配置。</li>
<li>Hybrid 模式：Hybrid 模式是 Enviroment 模式与 Micro-Project 模式的组合，Stack 不仅可以表示 Project 部署的不同环境，也可以表示 Micro-Project。一般而言，具有 Micro-Project 特性的 Stack 可以和某个具有 Enviroment 特性的 Stack 共同提供 Project 在该环境下的全部配置。具有 Micro-Project 特性的 Stack 往往需要在 Project 的不同环境间进行复用。具有 Enviroment 特性的 Stack 可能也不包含 Project 的需要全部配置。</li>
</ol>
<blockquote>
<p><strong>Note:</strong> 在 Hybrid 模式中，具有 Micro-Project 特性的 Stack 和 base 文件夹均可提供不同环境中的通用能力，两者存在如下两点不同。1、具有 Micro-Project 特性的 Stack 可以进行编译、部署成一个基础设施实体，而 base 无法和一个基础设施实体进行对应；2、具有 Micro-Project 特性的 Stack 表示一个较小 Project 的配置，而 base 表示多个环境和 Micro-Project 的通用配置。总的来说，只需记住具有 Micro-Project 特性的 Stack 仍是一个 Stack，具备 Stack 的特性；而 base 文件夹只是通用 KCL 程序的集合，并不具备 Stack 的特性。</p>
</blockquote>
<h2 id="325-project-和-stack-的工程结构"><a class="header" href="#325-project-和-stack-的工程结构">3.2.5 Project 和 Stack 的工程结构</a></h2>
<p>用户可以灵活地组织 Project 和 Stack 的工程结构，只需遵循如下 2 个规则：</p>
<ol>
<li>Stack 目录必须位于 Project 目录下，但不要求 Stack 目录是 Project 目录的下一层；</li>
<li>Project 之间和 Stack 之间不可嵌套，即不允许一个 Project 目录下有另一个 Project 目录，一个 Stack 目录下有另一个 Stack 目录。</li>
</ol>
<p>我们推荐用户把 Project 和 Stack 名称作为对应的文件夹名称，但这不是必须的。用户可以根据自身需求对 Project 和 Stack 进行分类，组织对应的目录结构。一种常见的目录结构遵循 <a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B">康威定律</a>：<code>Project_Type/Orgnization_Name/Project_Name/Stack_Name</code> 项目的类型、组织结构的类型和代码保存相似的映射关系。</p>
<h2 id="326-例子nginx"><a class="header" href="#326-例子nginx">3.2.6 例子：Nginx</a></h2>
<p>以 Konfig 中自带的 <a href="https://github.com/KusionStack/konfig/tree/master/appops/nginx-example">appops/nginx-example</a> 为例，下面是对应的目录和文件结构：</p>
<pre><code class="language-bash">appops/nginx-example
├── README.md       # Project 介绍文件
├── base            # 各环境通用配置
│   └── base.k      # 通用 KCL 配置
├── dev             # 环境特有配置
│   ├── ci-test     # 测试目录
│   │   ├── settings.yaml       # 测试数据
│   │   └── stdout.golden.yaml  # 测试期望结果
│   ├── kcl.yaml    # 多文件编译配置，是 KCL 编译的入口
│   ├── main.k      # 当前环境 KCL 配置
│   └── stack.yaml  # Stack 配置文件
└── project.yaml    # Project 配置文件
</code></pre>
<p>根目录中有 <code>project.yaml</code> 文件表示对应一个 Project，然后 <code>dev/stack.yaml</code> 表示对应 Stack，base 目录对应基线配置（不是一个 Stack）。<code>dev/ci-test</code> 是测试相关配置和数据，<code>kcl.yaml</code> 和 <code>main.h</code> 是应用的 KCL 配置程序代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-state--backends"><a class="header" href="#33-state--backends">3.3 State &amp; Backends</a></h1>
<p>本节介绍 State &amp; Backends，它们是 Kusion 引擎如何存储状态和对接不同平台的关键概念。</p>
<h2 id="331-架构图"><a class="header" href="#331-架构图">3.3.1 架构图</a></h2>
<p>Kusion 工具的核心之一是一个结构化配置数据的状态按需执行框架引擎，其前端通过 KCL 开发的配置产出 YAML 等价的配置数据，然后通过可热插拔的后端执行引擎将 YAML 配置数据按需应用到不同的云原生平台。</p>
<p><img src="ch3-internal/../images/ch3.3-kusion-arch-01.png" alt="" /></p>
<h2 id="332-state"><a class="header" href="#332-state">3.3.2 State</a></h2>
<p>State 用于存储资源下发后 Backend 驱动返回的状态，是对于 IaaS 状态的映射。用户执行 Apply 命令时，Kusion 会根据 Konfig 与 State 之间的差异，来按需执行资源创建、更新或删除操作。用户执行 Apply 命令后，Kusion 会根据 Backend 返回的信息更新 state 状态。</p>
<p>Kusion state 默认存储于&quot;kusion_state.json&quot;文件中，也可存储于远程后端，便于团队协作。</p>
<h2 id="333-backends"><a class="header" href="#333-backends">3.3.3 Backends</a></h2>
<p>Kusion state 表示存储 Backend 状态的存储配置，默认情况下使用 Local 类型表示的本地磁盘存储状态。对于团队协作项目，State 可存储在远程服务上供多人共享使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-和上游下游的关系"><a class="header" href="#34-和上游下游的关系">3.4 和上游下游的关系</a></h1>
<p>Kusion 作为一个面向云原生的可编程配置技术栈并不是一个独立的技术孤岛，相反只有和整个生态的上下游工具协作配合才是最佳的实践。本节介绍 Kusion 和上游下游的关系。</p>
<h2 id="341-协作关系图"><a class="header" href="#341-协作关系图">3.4.1 协作关系图</a></h2>
<p>从开发者和 SRE 开发维护配置、然后通过各种 CICD 系统对接到 Kusion 核心引擎，最终对接到目标平台。Kusion 整个工作流中和周边生态的协作关系图如下：</p>
<p><img src="ch3-internal/../images/ch3.4-kusion-connect-x-01.png" alt="" /></p>
<p>Kusion 涉及的上下游相关项目有：Kubernetes 自身及生态技术、Kubenetes 运维自动化技术、GitOps CICD 系统、IaaS 管理技术及各个云厂商和 IaC 领域语言及数据格式等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-场景-日常运维"><a class="header" href="#4-场景-日常运维">4. 场景: 日常运维</a></h1>
<p>本章尝试通过展示部署应用、为应用配置监控、资源容量和镜像升级等常见的运维操作展示 Kusion 在 SRE 日常运维中是用法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="41-部署-deployment"><a class="header" href="#41-部署-deployment">4.1 部署 Deployment</a></h1>
<p>本节展示如何使用 Kusion 配套工具，完成一个 Kubernetes 的 Deployment 的部署。</p>
<h2 id="411-准备开始"><a class="header" href="#411-准备开始">4.1.1 准备开始</a></h2>
<p>在开始之前，我们需要做以下准备工作：</p>
<p>1、安装 Kusion 工具链</p>
<p>我们推荐使用 kusion 的官方安装工具 <code>kusionup</code>，可实现 kusion 多版本管理等关键能力。详情信息请参阅<a href="https://kusionstack.io/docs/user_docs/getting-started/install">下载和安装</a>。</p>
<p>2、下载开源 Konfig 大库</p>
<p>在本篇指南中，需要用到部分已经抽象实现的 KCL 模型，有关 KCL 语言的介绍，可以参考 <a href="https://kusionstack.io/docs/reference/lang/lang/tour">Tour of KCL</a>。</p>
<p>仓库地址： <a href="https://github.com/KusionStack/konfig.git">https://github.com/KusionStack/konfig.git</a></p>
<p>3、可用的 Kubernetes 集群</p>
<p>必须要有一个 Kubernetes 集群，同时 Kubernetes 集群最好带有 <a href="https://kubernetes.io/docs/tasks/tools/#kubectl">kubectl</a> 命令行工具。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a> 构建一个你自己的集群。</p>
<blockquote>
<p>本指南要求你对 Kubernetes 有基本的了解。不清楚相关概念的，可以前往 Kubernetes 官方网站，查看相关说明：</p>
</blockquote>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">Learn Kubernetes Basics</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">Namespace</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a></li>
</ul>
<h2 id="412-初始化"><a class="header" href="#412-初始化">4.1.2 初始化</a></h2>
<p>本指南是以 KCL 和 Kusion 的方式部署 Deployment，依赖 kusion 工具、Konfig 大库和 Kubernetes 集群。</p>
<p>打开 Konfig 大库项目，进入 <code>appops</code> 目录，初始化 KCL 项目：</p>
<pre><code class="language-bash">cd appops &amp;&amp; kusion init
</code></pre>
<p><code>kusion init</code> 命令会提示你输入可能需要的参数，例如项目名称、项目描述，镜像地址等；也可以一路点击 <em>回车</em> 使用默认值。输出类似于：</p>
<pre><code>✔ deployment-single-stack    A minimal kusion project of single stack
This command will walk you through creating a new kusion project.

Enter a value or leave blank to accept the (default), and press &lt;ENTER&gt;.
Press ^C at any time to quit.

✔ project name: deployment-single-stack
✔ project description: A minimal kusion project of single stack
✔ Stack: dev
✔ ClusterName: kubernetes-dev
✔ Image: gcr.io/google-samples/gb-frontend:v4
Created project 'deployment-single-stack'
</code></pre>
<p>到此，我们就成功初始化一个 KCL 项目：deployment-single-stack，该代码包含一个 Project 和一个 Stack。
其中，<code>project name</code> 和 <code>project description</code> 是每个模板都需要设置的属性，目的是为了模板共享。
剩余三个字段，是模板中需要用户填入的三个属性，<code>Stack</code> 表示配置栈的名称，可以理解为配置的隔离标识；
<code>ClusterName</code> 是指集群名称，在本例中暂未使用；<code>Image</code> 表示 Deployment 的主容器的镜像地址。</p>
<blockquote>
<p>有关 Project 和 Stack 的设计说明，请参阅 <a href="https://kusionstack.io/docs/user_docs/concepts/project-stack">Project&amp;Stack</a>。</p>
</blockquote>
<p>该项目的目录结构如下：</p>
<pre><code>deployment-single-stack
├── README.md
├── base
│   └── base.k
├── dev
│   ├── ci-test
│   │   └── settings.yaml
│   ├── kcl.yaml
│   ├── main.k
│   └── stack.yaml
├── kusion.yaml
└── project.yaml

3 directories, 8 files
</code></pre>
<p>可以看到，目录共分成三层，每层目录都有各自的设计意义。
根目录下 <code>project.yaml</code> 表示项目级别的属性；<code>kusion.yaml</code> 是模板的配置文件，与本指南的操作内容无关。
<code>base</code> 目录存放的是公共配置；<code>dev</code> 目录存放的是定制化配置，<code>kcl.yaml</code> 是静态编译配置，指定了编译文件，
<code>main.k</code> 是定制化配置的具体代码，<code>stack.yaml</code> 存放的是是配置栈的描述信息；
<code>dev/ci-test</code> 目录存放的是动态编译配置和最终输出，默认情况下，编译输出到该目录下的 <code>stdout.golden.yaml</code> 文件。
整体来说，<code>.k</code> 文件是 KCL 源码，<code>.yaml</code> 是配置文件。</p>
<h2 id="413-配置编译"><a class="header" href="#413-配置编译">4.1.3 配置编译</a></h2>
<p>到此，已经借助 kusion 提供的内置模板，完成了项目的开发。
项目的编程语言是 KCL，不是 Kubernetes 认识的 JSON/YAML，因此还需要编译得到最终输出。</p>
<p>首先进入到项目的 Stack 目录（<code>deployment-single-stack/dev</code>）并执行编译：</p>
<pre><code class="language-bash">cd deployment-single-stack/dev &amp;&amp; kusion compile
</code></pre>
<p>输出默认保存在 <code>deployment-single-stack/dev/ci-test/stdout.golden.yaml</code> 文件中。</p>
<blockquote>
<p>有关 kusion 命令行工具的说明，执行 <code>kusion -h</code>，或者参考工具的在线文档 <a href="https://kusionstack.io/docs/reference/cli/kusionctl/overview">Overview of Kusion CLI</a>。</p>
</blockquote>
<h2 id="414-配置生效"><a class="header" href="#414-配置生效">4.1.4 配置生效</a></h2>
<p>完成编译，现在开始下发配置。通过查看 <code>stdout.golden.yaml</code> 文件，可以看到 3 个资源：</p>
<ul>
<li>一个 name 为 deployment-single-stackdev 的 Deployment</li>
<li>一个 name 为 deployment-single-stack 的 Namespace</li>
<li>一个 name 为 frontend-service 的 Service</li>
</ul>
<p>该文件的内容已经是 Kubernetes 能够识别的配置，可以使用 <code>kubectl apply -f stdout.golden.yaml</code> 直接下发配置，
也可以使用 <code>kusion apply</code> 完成配置编译并下发（该命令包含了配置编译）。</p>
<blockquote>
<p>推荐使用 kusion 工具，本例中的编译输出是完整的 YAML 声明，但不是所有的 KCL 项目编译结果都是如此。</p>
</blockquote>
<p>执行命令：</p>
<pre><code class="language-bash">kusion apply
</code></pre>
<p>输出类似于：</p>
<pre><code>SUCCESS  Compiling in stack dev...

Stack: dev    Provider                Type                           Name    Plan
      * ├─  kubernetes        v1:Namespace     deployment-single-stack[0]  Create
      * ├─  kubernetes  apps/v1:Deployment  deployment-single-stackdev[0]  Create
      * └─  kubernetes          v1:Service            frontend-service[0]  Create

✔ yes
Start applying diffs......
 SUCCESS  Creating Namespace/deployment-single-stack     
 SUCCESS  Creating Deployment/deployment-single-stackdev
 SUCCESS  Creating Service/frontend-service
Creating Service/frontend-service [3/3] ███████████████████████████████████████████ 100% | 0s

Apply complete! Resources: 3 created, 0 updated, 0 deleted.
</code></pre>
<p>以上就完成了配置生效，可以使用 <code>kubectl</code> 工具检查资源的实际状态。</p>
<p>1、 检查 Namespace</p>
<pre><code class="language-bash">kubectl get ns
</code></pre>
<p>输出类似于：</p>
<pre><code>NAME                      STATUS        AGE
argocd                    Active        59d
default                   Active        72d
deployment-single-stack   Active        10m
</code></pre>
<p>2、检查 Deployment</p>
<pre><code class="language-bash">kubectl get deploy -n deployment-single-stack
</code></pre>
<p>输出类似于：</p>
<pre><code>NAME                         READY   UP-TO-DATE   AVAILABLE   AGE
deployment-single-stackdev   1/1     1            1           11m
</code></pre>
<p>3、检查 Service</p>
<pre><code class="language-bash">kubectl get svc -n deployment-single-stack
</code></pre>
<p>输出类似于：</p>
<pre><code>NAME               TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
frontend-service   NodePort   10.0.0.1       &lt;none&gt;        80:30226/TCP   11m
</code></pre>
<p>4、检查应用</p>
<p>使用 <code>kubecl</code> 工具，将本机端口 <code>30000</code> 映射到 Service 端口 <code>80</code></p>
<pre><code class="language-bash">kubectl port-forward svc/frontend-service -n deployment-single-stack-xx 30000:80
</code></pre>
<h2 id="415-查看效果"><a class="header" href="#415-查看效果">4.1.5 查看效果</a></h2>
<p>打开浏览器访问 <a href="http://127.0.0.1:30000">http://127.0.0.1:30000</a>：</p>
<p><img src="ch4-devops/../images/ch4.1-app-preview.jpg" alt="" /></p>
<p>正常可以看到类似以上界面。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="42-为应用配置监控"><a class="header" href="#42-为应用配置监控">4.2 为应用配置监控</a></h1>
<p>本节展示如何为应用配置监控，通过 Prometheus 查看应用状态。</p>
<h2 id="421-准备工作"><a class="header" href="#421-准备工作">4.2.1 准备工作</a></h2>
<p>我们将展示以下内容：初始化配置代码、使能监控配置和查看监控面板。在开始前需要安装 KusionCtl、Minikube 和 <a href="https://github.com/prometheus-operator/kube-prometheus">kube-prometheus</a>。</p>
<h2 id="422-初始化配置代码"><a class="header" href="#422-初始化配置代码">4.2.2 初始化配置代码</a></h2>
<p>通过 kusion 命令行工具初始化代码：</p>
<pre><code>$ kusion init
✔ Server
project name: prometheus-example-app
stack name: prod
cluster name: default
image: quay.io/brancz/prometheus-example-app:v0.3.0
</code></pre>
<p>其中 <code>quay.io/brancz/prometheus-example-app:v0.3.0</code> 镜像对应的应用代码可参考：<a href="https://github.com/brancz/prometheus-example-app">https://github.com/brancz/prometheus-example-app</a>。</p>
<p>这个应用程序是一个示例，说明如何使用 Prometheus 指标轻松监测 HTTP 处理程序，它使用 Prometheus go 客户端监听本地 <code>8080</code> 端口创建一个新的 Prometheus 注册表。</p>
<p>具体的监控指标如下：</p>
<ul>
<li>任何对 <code>/</code> 的请求都会产生一个 <code>200</code> 响应码，这会增加此响应代码的计数器指标</li>
<li>任何对 <code>/err</code> 的请求都将产生一个 <code>404</code> 响应代码，会增加相应计数器的指标</li>
</ul>
<h2 id="423-使能配置"><a class="header" href="#423-使能配置">4.2.3 使能配置</a></h2>
<p>通过将 <code>enableMonitoring</code> 设置为 <code>True</code> 使能配置，并添加主容器端口号配置 <code>8080</code>。代码如下：</p>
<pre><code class="language-py">import base.pkg.kusion_models.kube.frontend
import base.pkg.kusion_models.kube.frontend.container
import base.pkg.kusion_models.kube.frontend.container.env as e
import base.pkg.kusion_models.kube.frontend.container.port as cp
import base.pkg.kusion_models.kube.frontend.container.probe as p

# The application configuration in stack will overwrite 
# the configuration with the same attribute in base.
appConfiguration: frontend.Server {
    # Main container configuration
    mainContainer: container.Main {
        name = &quot;prometheus-example-app&quot;
        ports = [
            cp.ContainerPort {
                name = &quot;web&quot;
                containerPort = 8080
            }
        ]
    }
    enableMonitoring = True
}
</code></pre>
<p>配置 web 服务端口号。</p>
<h2 id="424-查看监控面板"><a class="header" href="#424-查看监控面板">4.2.4 查看监控面板</a></h2>
<p>通过 <code>kusion apply</code> 命令部署配置:</p>
<pre><code> SUCCESS  Compiling in stack prod...                                                                                                  

Stack: prod    Provider                                 Type                           Name    Plan
       * ├─  kubernetes                         v1:Namespace      prometheus-example-app[0]  Create
       * ├─  kubernetes  monitoring.coreos.com/v1:PodMonitor  prometheus-example-appprod[0]  Create
       * └─  kubernetes                   apps/v1:Deployment  prometheus-example-appprod[0]  Create
</code></pre>
<p>可以看到，除了部署 kubernetes <code>Deployment</code> 和 <code>Namespace</code> 资源外，还额外部署了 <code>PodMonitor</code> 资源用于配置 Prometheus 监听应用 Pod，当资源都创建完成时，可以通过如下命令查看 Prometheus 监控面板。</p>
<pre><code>kubectl --namespace monitoring port-forward svc/prometheus-k8s 9090
</code></pre>
<p>最后通过 http://localhost:9090 访问监控面板并查看应用程序的监控指标。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="43-扩展应用资源容量"><a class="header" href="#43-扩展应用资源容量">4.3 扩展应用资源容量</a></h1>
<p>本节展示如果扩展资源容量。</p>
<h2 id="431-准备条件"><a class="header" href="#431-准备条件">4.3.1 准备条件</a></h2>
<p>在开始之前同样需要安装 KusionCtl、Minikube 环境，然后将展示初始化配置代码、应用扩容等内容。</p>
<h2 id="432-配置资源规格"><a class="header" href="#432-配置资源规格">4.3.2 配置资源规格</a></h2>
<p>可以通过编辑 <code>schedulingStrategy.resource</code> 的值来设置主容器的资源规格。有两个方法修改资源规格，一种是修改 resource 表达式中 cpu、memory 的值：</p>
<!-- TODO: 给出模型参考链接 -->
<pre><code class="language-py">import base.pkg.kusion_models.kube.frontend
import base.pkg.kusion_models.kube.frontend.resource as res

appConfiguration: frontend.Server {
    # 修改 resource 表达式中 cpu、memory 的值
    # 原值：schedulingStrategy.resource = &quot;cpu=100m,memory=100Mi,disk=1Gi&quot;
    # 新的值（应用扩容）：
    schedulingStrategy.resource = res.Resource {
        cpu = 500m
        memory = 500Mi
        disk = 1Gi
    }
}
</code></pre>
<p>另一种是使用预置的 resource 值替代原值来进行应用扩容：</p>
<pre><code class="language-py">import base.pkg.kusion_models.kube.frontend
import base.pkg.kusion_models.kube.templates.resource as res_tpl

appConfiguration: frontend.Server {
    # 使用预置的 resource 值替代原值来进行应用扩容：
    # 原值：schedulingStrategy.resource = &quot;cpu=100m,memory=100Mi,disk=1Gi&quot;
    # 新的值（应用扩容）：
    schedulingStrategy.resource = res_tpl.large
}
</code></pre>
<p>上述代码是样例配置，可以根据 SchedulingStrategy 模型定义和实际情况添加自定义配置：</p>
<pre><code class="language-py">import base.pkg.kusion_models.kube.frontend.resource as res

schema SchedulingStrategy:
    &quot;&quot;&quot; SchedulingStrategy represents scheduling strategy.

    Attributes
    ----------
    resource: str | res.Resource, default is &quot;1&lt;cpu&lt;2,1Gi&lt;memory&lt;2Gi,disk=20Gi&quot;, required.
        A Pod-level attribute.
        Main container resource.
    &quot;&quot;&quot;
    resource: str | res.Resource = &quot;1&lt;cpu&lt;2,1Gi&lt;memory&lt;2Gi,disk=20Gi&quot;
</code></pre>
<h2 id="433-配置生效"><a class="header" href="#433-配置生效">4.3.3 配置生效</a></h2>
<p>执行以下命令将升级后的镜像进行生效：</p>
<pre><code>$ kusion apply
SUCCESS  Compiling in stack dev...

Stack: dev    Provider                Type              Name    Plan
      * ├─  kubernetes        v1:Namespace              demo  UnChange
      * ├─  kubernetes          v1:Service      demo-service  UnChange
      * └─  kubernetes  apps/v1:Deployment           demodev  Update

✔ yes
SUCCESS  Updating apps/v1:Deployment
Updating apps/v1:Deployment [1/1] ████████████████████████████████ 100% | 0s
</code></pre>
<p>通过 Kubernetes 工具查看资源验证。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="44-应用镜像升级"><a class="header" href="#44-应用镜像升级">4.4 应用镜像升级</a></h1>
<p>本节展示如何升级应用镜像。</p>
<h2 id="441-准备条件"><a class="header" href="#441-准备条件">4.4.1 准备条件</a></h2>
<p>在开始之前同样需要安装 KusionCtl、Minikube 环境，然后将展示通过修改配置代码完成镜像升级工作。</p>
<h2 id="442-镜像升级"><a class="header" href="#442-镜像升级">4.4.2 镜像升级</a></h2>
<p>编辑 <code>dev/main.k</code> 中的 image 的值：</p>
<pre><code class="language-py">import base.pkg.kusion_models.kube.frontend

appConfiguration: frontend.Server {
    # 修改 image 的值为要升级的版本
    # image = &quot;gcr.io/google-samples/gb-frontend:v4&quot;
    image = &quot;gcr.io/google-samples/gb-frontend:v5&quot;
}
</code></pre>
<h2 id="443-配置生效"><a class="header" href="#443-配置生效">4.4.3 配置生效</a></h2>
<p>执行以下命令将升级后的镜像进行生效：</p>
<pre><code>$ kusion apply
SUCCESS  Compiling in stack dev...

Stack: dev    Provider                Type              Name    Plan
      * ├─  kubernetes        v1:Namespace              demo  UnChange
      * ├─  kubernetes          v1:Service      demo-service  Update
      * └─  kubernetes  apps/v1:Deployment           demodev  UnChange

✔ yes
SUCCESS  Updating Service/demo-service
Updating Service/demo-service [1/1] ████████████████████████████████ 100% | 0s
</code></pre>
<p>通过 Kubernetes 工具查看资源验证。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="45-补充说明"><a class="header" href="#45-补充说明">4.5 补充说明</a></h1>
<p>为了适配云原生场景，Kusion 将一些概念内置到了最佳实践之中。本节补充解释一些云原生应用到概念。</p>
<h2 id="451-命名空间"><a class="header" href="#451-命名空间">4.5.1 命名空间</a></h2>
<p>在以应用为中心的运维体系中，通常可以借助 Kubernetes 中的命名空间（Namespace）进行应用之间的资源隔离，即以应用名作为命名空间名。
同时，支持应用部署的所有 Kubernetes 资源都部署到同一个命名空间中。</p>
<p>在 Kusion 技术栈推荐的目录工程结构中，可以在 Project 配置文件（project.yaml）中声明当前 Project 的 Name，
在应用运维场景中，Project Name 即是应用名称，默认也是命名空间名称。</p>
<blockquote>
<p>用户可以根据自己的业务需求修改命名空间，建议项目名称和命名空间保持一致，但不是硬性要求。</p>
</blockquote>
<p>通过上一步初始化的样例，可以从 <code>project.yaml</code> 看到相关配置：</p>
<pre><code class="language-yaml"># The project basic info
name: deployment-single-stack
</code></pre>
<h2 id="452-资源规格"><a class="header" href="#452-资源规格">4.5.2 资源规格</a></h2>
<p>通过配置 <code>schedulingStrategy.resource</code> 设置应用主容器的资源规格，此配置存在于 <code>dev/main.k</code> 文件。</p>
<blockquote>
<p>有关资源规格的抽象定义，可以查看 Konfig 仓库中 <a href="https://github.com/KusionStack/konfig/blob/master/base/pkg/kusion_models/kube/templates/resource.k"><code>base/pkg/kusion_models/kube/templates/resource.k</code></a> 文件。</p>
</blockquote>
<p><code>dev/main.k</code> 中资源规格配置：</p>
<pre><code class="language-py">appConfiguration: frontend.Server {
    schedulingStrategy.resource = res_tpl.tiny
}
</code></pre>
<p>通过配置 schedulingStrategy.resource 设置主容器的资源规格，上面的赋值语句等价于：</p>
<pre><code class="language-py">import base.pkg.kusion_models.kube.frontend.resource as res

schedulingStrategy.resource = res.Resource {
    cpu = 100m
    memory = 100Mi
    disk = 1Gi
}
</code></pre>
<h2 id="453-主容器配置"><a class="header" href="#453-主容器配置">4.5.3 主容器配置</a></h2>
<p>通过配置 mainContainer 设置主容器，此配置存在于 <code>base/bask.k</code> 文件中。</p>
<blockquote>
<p>有关主容器的抽象定义，可以查看 Konfig 仓库中 <a href="https://kusionstack.io/docs/reference/model/kusion_models/kube/frontend/container/doc_container">base.pkg.kusion_models.kube.frontend.container</a> 模块的文档。</p>
</blockquote>
<p><code>base/bask.k</code> 中主容器配置：</p>
<pre><code class="language-py">appConfiguration: frontend.Server {
    # Main Container Configuration
    mainContainer = container.Main {
        name = &quot;php-redis&quot;
        env = [
            {
                name = &quot;GET_HOSTS_FROM&quot;
                value = &quot;dns&quot;
            }
        ]
        ports = [
            { containerPort = 80 }
        ]
    }
}
</code></pre>
<h2 id="454-差异化配置"><a class="header" href="#454-差异化配置">4.5.4 差异化配置</a></h2>
<p>通过 if-else 添加差异化配置，比如根据实际部署的集群名称设置不同的 labels。</p>
<blockquote>
<p>有关 KCL 语义相关的详细说明，请参阅<a href="https://kusionstack.io/docs/reference/lang/lang/spec/expressions">表达式</a>。</p>
</blockquote>
<p><code>base/bask.k</code> 中 Pod Label 的配置：</p>
<pre><code class="language-py">appConfiguration: frontend.Server {
    podMetadata.labels = {
        if __META_CLUSTER_NAME in [&quot;minikube&quot;, &quot;kind&quot;]:
            cluster = __META_CLUSTER_NAME
        else:
            cluster = &quot;other&quot;
    }
}
</code></pre>
<h2 id="455-服务配置"><a class="header" href="#455-服务配置">4.5.5 服务配置</a></h2>
<p>Service 的名称、类型、暴露的端口号等字段，可通过 <code>services</code> 字段配置。</p>
<blockquote>
<p>有关 <a href="https://kusionstack.io/docs/reference/model/kusion_models/kube/frontend/service/doc_service">Service</a> 的抽象定义，可以查看 Konfig 仓库中 <code>base/pkg/kusion_models/kube/frontend/service/service.k</code> 文件。</p>
</blockquote>
<p><code>base/bask.k</code> 中 Service 的配置：</p>
<pre><code class="language-py">appConfiguration: frontend.Server {
    services = [
        service.Service {
            name = &quot;frontend-service&quot;
            type = &quot;NodePort&quot;
            ports = [
                { port = 80 }
            ]
        }
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-场景-对接社区生态"><a class="header" href="#5-场景-对接社区生态">5. 场景: 对接社区生态</a></h1>
<p>开源社区和云原生的共同哲学都是协作发展，因此 Kusion 对接已有的社区生态是一个必然选项。本章通过 OpenAPI 和 Terraform 展示 Kusion 对接已有社区资源。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51-openapi"><a class="header" href="#51-openapi">5.1 OpenAPI</a></h1>
<p>对于全新的项目来说，您只需要从头开始采用 Kusion 技术栈编写和管理基础设施配置即可，我们提供了针对不同运行时的用户指南文档引导您这一过程。 然而，对于已经建设了基础设施的项目，可能已有存量的配置模型和数据，对此，Kusion 也提供了一些自动化工具帮助您快速迁移。</p>
<p>对于 kubernetes 用户，Kusion 提供了 OpenAPI 到 KCL 模型代码的转换工具，以直接复用 Kubernetes 已有的上百个核心模型。 对于 istio 用户，以及 Kubernetes 内置模型无法支持的情况， Kusion 还支持将 CRD 自动生成为 KCL 模型代码。</p>
<h2 id="511-kubernetes-openapi-spec"><a class="header" href="#511-kubernetes-openapi-spec">5.1.1 Kubernetes OpenAPI Spec</a></h2>
<p>从 Kubernetes 1.4 开始，引入了对 OpenAPI 规范（在捐赠给 Open API Initiative 之前称为 swagger 2.0）的 alpha 支持，API 描述遵循 <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md">OpenAPI 规范 2.0</a>，从 Kubernetes 1.5 开始，Kubernetes 能够直接从<a href="https://github.com/kubernetes/kube-openapi">源码自动地提取模型并生成 OpenAPI 规范</a>，自动化地保证了规范和文档与操作/模型的更新完全同步。</p>
<p>此外，Kubernetes CRD 使用 <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation">OpenAPI v3.0 validation</a> 来描述（除内置属性 apiVersion、kind、metadata 之外的）自定义 schema，在 CR 的创建和更新阶段，APIServer 会使用这个 schema 对 CR 的内容进行校验。</p>
<h2 id="512-kcl-openapi-支持"><a class="header" href="#512-kcl-openapi-支持">5.1.2 KCL OpenAPI 支持</a></h2>
<p>KCLOpenAPI 工具支持从 OpenAPI/CRD 定义提取并生成 KCL schema. 在 <a href="https://kusionstack.io/docs/reference/cli/openapi/spec">KCLOpenapi Spec</a> 中明确定义了 OpenAPI 规范与 KCL 语言之间的映射关系。</p>
<p><a href="https://kusionstack.io/docs/user_docs/getting-started/install">安装 Kusion 工具包</a>的同时会默认安装 KCLOpenapi 工具，KCLOpenapi 工具的使用和示例可参见 <a href="https://kusionstack.io/docs/reference/cli/openapi">KCLOpenAPI 工具</a></p>
<h2 id="513-从-kubernetes-模型迁移到-kusion"><a class="header" href="#513-从-kubernetes-模型迁移到-kusion">5.1.3 从 Kubernetes 模型迁移到 Kusion</a></h2>
<p>Kubernetes 内置模型的完整 OpenAPI 定义存放在 <a href="https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json">Kubernetes openapi-spec 文件</a>。以该文件作为输入，KCLOpenapi 工具能够生成相应版本的全部模型 schema. 接下来以发布部署场景为例，演示从 Kubernetes 迁移到 Kusion 的流程。假设您的项目正在使用 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Kubernetes Deployment</a> 定义发布部署配置，迁移到 Kusion 只需要如下几步：</p>
<h3 id="5131-kubernetes-deployment-转为-kcl-schema"><a class="header" href="#5131-kubernetes-deployment-转为-kcl-schema">5.1.3.1 Kubernetes Deployment 转为 KCL Schema</a></h3>
<p>从 <a href="https://github.com/kubernetes/kubernetes/blob/release-1.23/api/openapi-spec/swagger.json">Kubernetes 1.23 版本的 openapi-spec 文件</a>中，可以找到 apps/v1.Deployment 模型相关的定义，截取片段如下：</p>
<pre><code class="language-json">{
    &quot;definitions&quot;: {
        &quot;io.k8s.api.apps.v1.Deployment&quot;: {
            &quot;description&quot;: &quot;Deployment enables declarative updates for Pods and ReplicaSets.&quot;,
            &quot;properties&quot;: {
                &quot;apiVersion&quot;: {
                    &quot;description&quot;: &quot;APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources&quot;,
                    &quot;type&quot;: &quot;string&quot;
                },
                &quot;kind&quot;: {
                    &quot;description&quot;: &quot;Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds&quot;,
                    &quot;type&quot;: &quot;string&quot;
                },
                &quot;metadata&quot;: {
                    &quot;$ref&quot;: &quot;#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta&quot;,
                    &quot;description&quot;: &quot;Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata&quot;
                },
                &quot;spec&quot;: {
                    &quot;$ref&quot;: &quot;#/definitions/io.k8s.api.apps.v1.DeploymentSpec&quot;,
                    &quot;description&quot;: &quot;Specification of the desired behavior of the Deployment.&quot;
                },
                &quot;status&quot;: {
                    &quot;$ref&quot;: &quot;#/definitions/io.k8s.api.apps.v1.DeploymentStatus&quot;,
                    &quot;description&quot;: &quot;Most recently observed status of the Deployment.&quot;
                }
            },
            &quot;type&quot;: &quot;object&quot;,
            &quot;x-kubernetes-group-version-kind&quot;: [
                {
                    &quot;group&quot;: &quot;apps&quot;,
                    &quot;kind&quot;: &quot;Deployment&quot;,
                    &quot;version&quot;: &quot;v1&quot;
                }
            ]
        }
    },
    &quot;info&quot;: {
        &quot;title&quot;: &quot;Kubernetes&quot;,
        &quot;version&quot;: &quot;unversioned&quot;
    },
    &quot;paths&quot;: {},
    &quot;swagger&quot;: &quot;2.0&quot;
}
</code></pre>
<p>将以上述 spec 保存为 deployment.json，执行 <code>kclopenapi generate model -f deployment.json</code>，将在当前工作空间生成所有相关的 KCL schema 文件。在 Konfig 的 base/pkg/kusion_kubernetes 目录中，我们已经保存了一份由此生成的 <a href="https://github.com/KusionStack/konfig/blob/master/base/pkg/kusion_kubernetes/api/apps/v1/deployment.k">KCL 文件</a>，并生成了对应的模型文档。</p>
<!-- TODO: 模型文档加链接 -->
<h3 id="5132-使用生成的-kcl-schema"><a class="header" href="#5132-使用生成的-kcl-schema">5.1.3.2 使用生成的 KCL Schema</a></h3>
<ul>
<li>
<p>使用生成的模型，直接声明 KCL 配置</p>
<p>我们可以在 KCL 配置中直接实例化生成的 Deployment，得到一份部署声明，如下：</p>
<pre><code class="language-python">import kusion_kubernetes.api.apps.v1

frontend = v1.Deployment {
    metadata.name: &quot;frontend&quot;
    spec.selector.matchLabels: {app: guestbook, tier: frontend}
    replicas: 3
    template.metadata.labels: {app: guestbook, tier: frontend}
    spec.containers: [
        {
            name: php-redis
            image: gcr.io/google-samples/gb-frontend:v4
            resources.requests: { cpu: &quot;100m&quot;, memory: &quot;100Mi&quot;}
        }
        env: [{name: GET_HOSTS_FROM, value: dns}]
        ports: [{containerPort: 80}]
    ]
}
</code></pre>
<p>在 Konfig 仓库中增加以上配置声明，经过的编译后，其结果等价于 <a href="https://github.com/kubernetes/examples/blob/master/guestbook/frontend-deployment.yaml">Kubernetes examples guestbook-frontend</a>，关于 Konfig 仓库及编译命令可参考 <a href="https://kusionstack.io/docs/user_docs/getting-started/konfig">Konfig 模型库快速开始</a>。</p>
</li>
<li>
<p>最佳实践：对 Kubernetes 模型进一步抽象，定义用户友好的界面</p>
<p>由于 Kubernetes 内置模型较为原子化和复杂，我们推荐以 Kubernetes 原生模型作为后端输出的模型，而向用户暴露一份更为友好和简单的前端模型界面。在 Konfig 的 kusion_models 目录中已经保存了一份经过良好抽象的模型 —— Server 模型，点此查看 <a href="https://github.com/KusionStack/konfig/blob/master/base/pkg/kusion_models/kube/frontend/server.k">Server Schema</a></p>
</li>
</ul>
<h2 id="514-从-kubernetes-crd-迁移到-kusion"><a class="header" href="#514-从-kubernetes-crd-迁移到-kusion">5.1.4 从 Kubernetes CRD 迁移到 Kusion</a></h2>
<p>如果您的项目中使用了 CRD，也可以采用类似的模式，生成 CRD 对应的 KCL schema，并基于该 schema 声明 CR。使用 <code>kclopenapi generate model --crd --skip-validation -f your_crd.yaml</code> 命令从 CRD 生成 KCL Schema。或者使用 KCL 声明 CR 的模式与声明 Kubernetes 内置模型配置的模式相同，在此不做赘述。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="52-terraform"><a class="header" href="#52-terraform">5.2 Terraform</a></h1>
<p>Terraform 是一个 IT 基础架构自动化编排工具，它的口号是“Write, Plan, and Create Infrastructure as Code”，是一个“基础设施即代码”工具，类似于 AWS CloudFormation，允许您创建、更新和版本控制的 AWS 基础设施。目前其社区已经具备了大量的资源，Kusion 通过复用 Provider 生态来兼容社区的资源。</p>
<p>Kusion 通过兼容的方式支持 Terraform 的 Provider，同时借助第三方的工具可以方便将 Provider 支持的模型导出为 KCL 格式的 Schema 模型。用户可以在此基础之上继续封装更简化的 API。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-多平台-对接阿里云生态"><a class="header" href="#6-多平台-对接阿里云生态">6. 多平台: 对接阿里云生态</a></h1>
<p>阿里云是中国最大的云计算平台，提供了很多可定制的计算和数据处理能力，提供了对 Terraform 的支持。而 Kusion 底层可以对接 Terraform 的 Provider 生态，因此也通过 Kusion 也可以对基础设施进行编码，利用代码来进行资源的增删查改。本文展示如何通过 Kusion 管理 ECS 和 SLB 等资源。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="61-ecs-云主机"><a class="header" href="#61-ecs-云主机">6.1 ECS 云主机</a></h1>
<p>本文介绍如何使用 Kusion 创建一台 ECS 实例，以及必须的其他关联资源。</p>
<!--
https://help.aliyun.com/document_detail/95829.html
-->
<h2 id="611-准备条件"><a class="header" href="#611-准备条件">6.1.1 准备条件</a></h2>
<p>在开始之前，您还需要一个阿里云账号和访问密钥（AccessKey）。 请在阿里云控制台中的 <a href="https://usercenter.console.aliyun.com/?spm=a2c4g.11186623.0.0.12321153zTjLcm#/manage/ak">AccessKey 管理页面</a> 上创建和查看您的 AccessKey。</p>
<p>本节用到的阿里云资源在 Konfig 中的 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义（还在开发中，查看 <a href="https://github.com/KusionStack/konfig/tree/dev/yuanyi/add_aliyun_and_aws/base/pkg/kusion_models/clouds/alicloud">代码</a>）。</p>
<p>要创建一个 ECS 机器，还需要创建对应的安全组和交换机，而安全组和交换机需依赖一个虚拟网络，它们的关系如图所示：</p>
<p><img src="ch6-multi-cloud/../images/ch6.1-ecs-01.png" alt="" /></p>
<p>下面我们将通过 Kusion 配置代码化的方式构建以上需要的资源。</p>
<h2 id="612-生成专有网络"><a class="header" href="#612-生成专有网络">6.1.2 生成专有网络</a></h2>
<p>专有网络 VPC（Virtual Private Cloud）是用户基于阿里云创建的自定义私有网络, 不同的专有网络之间二层逻辑隔离，用户可以在自己创建的专有网络内创建和管理云产品实例，比如 ECS、SLB、RDS 等。详细专有网络 VPC 创建信息查看 <a href="https://help.aliyun.com/document_detail/65398.html#section-znz-rbv-vrx">阿里云 VPC 文档</a> 。</p>
<p>专有网络对应 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义的 <code>AlicloudVPC</code> 模型（TODO：参考链接）：</p>
<pre><code class="language-py">schema AlicloudVPC:
    name?: str
    cidr_block?: str
    ...
</code></pre>
<p>目前只使用到 <code>name</code> 名称字段和 <code>cidr_block</code> IPv4 网段字段。然后初始化一个名称为 <code>alicloud_vpc</code>，子网地址为 <code>172.16.0.0/16</code> 的专有网络。</p>
<p>专业网络配置参数初始化代码如下：</p>
<pre><code class="language-py">_vpc = alicloud.AlicloudVPC {
    name       = &quot;alicloud_vpc&quot;
    cidr_block = &quot;172.16.0.0/16&quot;
}
</code></pre>
<p>有了专有网络配置参数之后还需要通过阿里云提供的 Terraform Provider 实例化，类型 <a href="https://github.com/KusionStack/konfig/blob/develop/base/pkg/kusion_models/commons/provider_resource.k"><code>base.pkg.kusion_models.commons.provider_resource</code></a> 包定义。对应的 Kusion 代码如下：</p>
<pre><code class="language-py">vpc = provider.Provider {
    providerName = &quot;alicloud&quot;
    resourceType = &quot;alicloud_vpc&quot;
    providerData = _vpc

    providerMeta = {
        region      = &quot;cn-beijing&quot;
        access_key  = &quot;L****************3&quot;
        secret_key  = &quot;x****************o&quot;
    }
}
</code></pre>
<p>其中 <code>alicloud</code> 和 <code>alicloud_vpc</code> 指定阿里云的 VPC 专有网络类型的资源；<code>_vpc</code> 是对应上面专业网络的配置；对应区域为 <code>cn-beijing</code>，还有对应的 AccessKey 信息。</p>
<h2 id="613-生成交换机vswitch"><a class="header" href="#613-生成交换机vswitch">6.1.3 生成交换机（VSwitch）</a></h2>
<p>交换机（vSwitch）是组成专有网络的基础网络模块，用来连接不同的云资源。成功创建交换机后，您可以在交换机中创建云资源、绑定自定义路由表或者绑定网络 ACL。详细交换机使用信息查看 <a href="https://help.aliyun.com/document_detail/65387.html#section-ts9-t3s-8vw">阿里云使用交换机文档</a> 。</p>
<p>交换机对应 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义的 <code>AlicloudVswitch</code> 模型（TODO：参考链接）：</p>
<pre><code class="language-py">schema AlicloudVswitch:
    vpc_id: str

    name?: str
    availability_zone?: str
    cidr_block: str
    ...
</code></pre>
<p>目前需要的字段有 <code>vpc_id</code> 对应的专有网络、<code>name</code> 名称字段和 <code>availability_zone</code> 可用区、<code>cidr_block</code> IPv4 网段</p>
<p>初始化交换机配置参数如下：</p>
<pre><code class="language-py">_vswitch = alicloud.AlicloudVswitch {
    vpc_id = &quot;$kusion_path.registry.terraform.io/aliyun/alicloud.alicloud_vpc.alicloud_provider.alicloud_vpc.id&quot;

    name              = &quot;alicloud_vswitch&quot;
    availability_zone = &quot;cn-beijing-b&quot;
    cidr_block        = &quot;172.16.0.0/21&quot;
}
</code></pre>
<p>需要注意的是 <code>vpc_id</code> 和前面创建的专有网络有关联关系。然后通过阿里云的 Provider 进行资源实例化：</p>
<pre><code class="language-py">vswitch = provider.Provider {
    providerDependOn = [
        &quot;registry.terraform.io/aliyun/alicloud.alicloud_vpc.alicloud_provider.alicloud_vpc&quot;
    ]

    providerName = &quot;alicloud&quot;
    resourceType = &quot;alicloud_vswitch&quot;
    providerData =  _vswitch

    providerMeta = {
        region      = &quot;cn-beijing&quot;
        access_key  = &quot;L****************3&quot;
        secret_key  = &quot;x****************o&quot;
    }
}
</code></pre>
<p>通过 providerDependOn 定义交换机创建依赖专有网络的创建的依赖关系。其他的可用区和 AccessKey 等参数和专有网络实例化类似。</p>
<h2 id="614-生成安全组securitygroup"><a class="header" href="#614-生成安全组securitygroup">6.1.4 生成安全组（SecurityGroup）</a></h2>
<p>安全组是 ECS 实例的虚拟防火墙，用于设置单个或多个 ECS 实例的网络访问控制，每台 ECS 实例至少需要属于一个安全组。详细安全组创建信息查看 <a href="https://help.aliyun.com/document_detail/25468.html">阿里云安全组创建文档</a> 。</p>
<p>交换机对应 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义的 <code>AlicloudSecurityGroup</code> 模型（TODO：参考链接）：</p>
<pre><code class="language-py">schema AlicloudSecurityGroup:
    vpc_id?: str

    name?: str
    description?: str
    ...
</code></pre>
<p>目前需要的字段有 <code>vpc_id</code> 对应的专有网络、<code>name</code> 名称字段和 <code>description</code> 描述字段。</p>
<p>初始化安全组配置参数如下：</p>
<pre><code class="language-py">#create secutirygroup 
_security_group = alicloud.AlicloudSecurityGroup {
    vpc_id = &quot;$kusion_path.registry.terraform.io/aliyun/alicloud.alicloud_vpc.alicloud_provider.alicloud_vpc.id&quot;

    name        = &quot;alicloud_security_group&quot;
    description = &quot;alicloud-security-group&quot;
}
</code></pre>
<p>需要注意的是 <code>vpc_id</code> 和前面创建的专有网络有关联关系。然后通过阿里云的 Provider 进行资源实例化：</p>
<pre><code class="language-py">security_group = provider.Provider {
    providerDependOn = [
        &quot;registry.terraform.io/aliyun/alicloud.alicloud_vpc.alicloud_provider.alicloud_vpc&quot;
    ]

    providerName = &quot;alicloud&quot;
    resourceType = &quot;alicloud_security_group&quot;
    providerData = _security_group

    providerMeta = {
        region     = &quot;cn-beijing&quot;
        access_key = &quot;L****************3&quot;
        secret_key = &quot;x****************o&quot;
    }
}
</code></pre>
<p>通过 providerDependOn 定义安全组创建依赖专有网络的创建的依赖关系。其他的可用区和 AccessKey 等参数和专有网络实例化类似。</p>
<h2 id="615-生成-ecs-实例"><a class="header" href="#615-生成-ecs-实例">6.1.5 生成 ECS 实例</a></h2>
<p>云服务器 ECS（Elastic Compute Service）是阿里云提供的性能卓越、稳定可靠、弹性扩展的 IaaS（Infrastructure as a Service）级别云计算服务。详细云服务器信息查看 <a href="https://help.aliyun.com/document_detail/87190.html">阿里云实例创建</a> 。</p>
<p>交换机对应 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义的 <code>AlicloudInstance</code> 模型（TODO：参考链接）：</p>
<pre><code>schema AlicloudInstance:
    availability_zone?: str

    vswitch_id?: str
    security_groups: [str]

    image_id: str
    instance_type: str
    instance_name?: str
    password?: str
    ...
</code></pre>
<p>其中 <code>vswitch_id</code> 引用交换机 <code>id</code> 字段，<code>availability_zone</code> 引用安全组 <code>id</code> 字段（依赖安全组的创建）。<code>image_id</code> 为镜像的 ID、<code>instance_type</code> 为机器的类型、<code>instance_name</code> 为机器的名字、<code>password</code> 是可选的参数。</p>
<p>初始化 ECS 配置参数如下：</p>
<pre><code class="language-py">_instance = alicloud.AlicloudInstance {
    availability_zone = &quot;cn-beijing-b&quot;

    vswitch_id = &quot;$kusion_path.registry.terraform.io/aliyun/alicloud.alicloud_vswitch.alicloud_provider.alicloud_vswitch.id&quot;
    security_groups = [
        &quot;$kusion_path.registry.terraform.io/aliyun/alicloud.alicloud_security_group.alicloud_provider.alicloud_security_group.id&quot;
    ]

    instance_type = &quot;ecs.n2.small&quot;
    image_id      = &quot;ubuntu_18_04_64_20G_alibase_20190624.vhd&quot;
    instance_name = &quot;kusion-alicloud-instance&quot;
    password      = &quot;Demo1234fd&quot;
}
</code></pre>
<p>需要注意的是 <code>vswitch_id</code> 和 <code>security_groups</code> 等配置对其他资源的依赖关系。然后通过阿里云的 Provider 进行资源实例化：</p>
<pre><code class="language-py">instance = provider.Provider {
    providerDependOn = [
        &quot;registry.terraform.io/aliyun/alicloud.alicloud_vswitch.alicloud_provider.alicloud_vswitch&quot;,
        &quot;registry.terraform.io/aliyun/alicloud.alicloud_security_group.alicloud_provider.alicloud_security_group&quot;
    ]

    providerName = &quot;alicloud&quot;
    resourceType = &quot;alicloud_instance&quot;
    providerData = _instance

    providerMeta = {
        region     = &quot;cn-beijing&quot;
        access_key = &quot;L****************3&quot;
        secret_key = &quot;x****************o&quot;
    }
}
</code></pre>
<p>通过 providerDependOn 定义安全组创建依赖专有网络的创建的依赖关系。其他的可用区和 AccessKey 等参数和专有网络实例化类似。</p>
<h2 id="616-执行-apply"><a class="header" href="#616-执行-apply">6.1.6 执行 Apply</a></h2>
<p>执行 <code>kusion apply</code> 命令创建资源：</p>
<p><img src="ch6-multi-cloud/../images/ch6.1-alicloud_instance_apply_console.png" alt="" /></p>
<p>然后运行 <code>ssh root@&lt;publicip&gt;</code>，并输入密码来访问 ECS 实例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="62-slb-负载均衡"><a class="header" href="#62-slb-负载均衡">6.2 SLB 负载均衡</a></h1>
<p>本文介绍如何使用 Kusion 创建负载均衡。</p>
<!--
https://help.aliyun.com/document_detail/111830.html
https://help.aliyun.com/document_detail/111634.html
-->
<h2 id="621-准备条件"><a class="header" href="#621-准备条件">6.2.1 准备条件</a></h2>
<p>在开始之前，您还需要一个阿里云账号和访问密钥（AccessKey）。 请在阿里云控制台中的 <a href="https://usercenter.console.aliyun.com/?spm=a2c4g.11186623.0.0.12321153zTjLcm#/manage/ak">AccessKey 管理页面</a> 上创建和查看您的 AccessKey。</p>
<p>本节用到的阿里云资源在 Konfig 中的 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义（还在开发中，查看 <a href="https://github.com/KusionStack/konfig/tree/dev/yuanyi/add_aliyun_and_aws/base/pkg/kusion_models/clouds/alicloud">代码</a>）。</p>
<h2 id="622-负载均衡"><a class="header" href="#622-负载均衡">6.2.2 负载均衡</a></h2>
<p>阿里云 <a href="https://help.aliyun.com/product/27537.html">负载均衡 SLB（Server Load Balancer）</a> 是一种对流量进行按需分发的服务，通过将流量分发到不同的后端服务来扩展应用系统的服务吞吐能力，并且可以消除系统中的单点故障，提升应用系统的可用性。</p>
<p>专有网络对应 <code>base.pkg.kusion_models.clouds.alicloud</code> 包定义的 <code>AlicloudSLB</code> 模型（TODO：参考链接）：</p>
<pre><code class="language-py">schema AlicloudSLB:
    name?: str
    load_balancer_name?: str
    load_balancer_spec?: str

    address_type?: str
    internet_charge_type?: str
    vswitch_id?: str
    ...
</code></pre>
<p>负载均衡同样要依赖交换机和专有网络，具体可以参考 6.1 节内容，这里不再重逢。负载均衡配置参数初始化代码如下：</p>
<pre><code class="language-py">_slb = alicloud.AlicloudSLB {
    name = &quot;alicloud_load_balancer&quot;

    load_balancer_name = &quot;alicloud_load_balancer&quot;
    load_balancer_spec = &quot;slb.s1.small&quot;

    address_type         = &quot;intranet&quot;
    internet_charge_type = &quot;PayByTraffic&quot;
    vswitch_id           = &quot;$kusion_path.registry.terraform.io/aliyun/alicloud.alicloud_vswitch.alicloud_provider.alicloud_vswitch.id&quot;
}
</code></pre>
<p>然后通过阿里云的 Provider 进行资源实例化：</p>
<pre><code class="language-py">slb = provider.Provider {
    providerDependOn = [
        &quot;registry.terraform.io/aliyun/alicloud.alicloud_vswitch.alicloud_provider.alicloud_vswitch&quot;
    ]

    providerName = &quot;alicloud&quot;
    resourceType = &quot;alicloud_slb_load_balancer&quot;
    providerData = _slb

    providerMeta = {
        region     = &quot;cn-beijing&quot;
        access_key = &quot;L****************3&quot;
        secret_key = &quot;x****************o&quot;
    }
}
</code></pre>
<p>通过 providerDependOn 定义负载均衡创建依赖专有网络的创建的依赖关系。其他的可用区和 AccessKey 等参数和专有网络实例化类似。</p>
<h2 id="623-执行-apply"><a class="header" href="#623-执行-apply">6.2.3 执行 Apply</a></h2>
<p>执行 <code>kusion apply</code> 命令创建资源：</p>
<p><img src="ch6-multi-cloud/../images/ch6.2-alicloud_slb_apply_console.png" alt="" /></p>
<p>打开 Web 页面查看负载均衡信息：</p>
<p><img src="ch6-multi-cloud/../images/ch6.2-alicloud_slb_apply_web.png" alt="" /></p>
<p>说明创建成功。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-开源社区"><a class="header" href="#7-开源社区">7. 开源社区</a></h1>
<p>Kusion 技术栈作为一种偏向基层设施的技术采用完全开源的模式运作。作为用户或者本书的读者也可以通过参与开源社区共建 Kusion 技术栈。本章简单介绍如何从社区获取帮助、如何为 Kusion 贡献文档和代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="71-寻求帮助"><a class="header" href="#71-寻求帮助">7.1 寻求帮助</a></h1>
<p>Kusion 有诸多爱好者组成的开发者和用户社群。在加入 Kusion 社群前，请先阅读 <a href="https://www.contributor-covenant.org/zh-cn/version/2/0/code_of_conduct">参与者公约</a>，期望所有社区成员都遵守该准则。</p>
<h2 id="711-讨论区"><a class="header" href="#711-讨论区">7.1.1 讨论区</a></h2>
<ul>
<li>在 Github 提交 issue</li>
<li>在 Github 讨论组进行交流</li>
<li>通过 官网、Github、Twitter、微博 等账户获取最新状态</li>
</ul>
<h2 id="712-新功能建议"><a class="header" href="#712-新功能建议">7.1.2 新功能建议</a></h2>
<p>请尽量避免提交新功能的合并请求 (Pull Request)，我们可能已有专人正在处理，或有可能此功能已经是我们未来规划的一部分。 总之，在提交新功能之前请先联系我们！</p>
<h2 id="714-分享和布道"><a class="header" href="#714-分享和布道">7.1.4 分享和布道</a></h2>
<p>和周边同学分享自己使用 Kusion 中遇到的问题和故事。</p>
<h2 id="715-最新资讯"><a class="header" href="#715-最新资讯">7.1.5 最新资讯</a></h2>
<p>请关注 Kusion 相关的项目和博客。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="72-贡献文档"><a class="header" href="#72-贡献文档">7.2 贡献文档</a></h1>
<p>文档是所有软件的对外接口，因此文档的好坏将直接影响用户的体验。作为开源项目，我们可以很容易参与 Kusion 文档的共建。</p>
<h2 id="721-文档的分类"><a class="header" href="#721-文档的分类">7.2.1 文档的分类</a></h2>
<p>Kusion 文档分为用户指南、开发文档、内部文档、参考手册和博客文章等，他们的区别如下：</p>
<ul>
<li>用户指南：对应使用文档，是让用户以最小的代价快速使用 Kusion 工具完整工作，不要涉及太多的内部原理和实现</li>
<li>开发文档：内部是怎么实现的，主要针对希望了解 Kusion 原理和参与贡献和开发的同学</li>
<li>内部文档：针对企业用户的一些内部场景定制的文档</li>
<li>参考手册：Kusion 工具、KCL 配置语言、模型库 等全部特性的文档，内容覆盖最广但比较琐碎</li>
<li>博客文章：没有特别的限制，可以是针对某些具体的场景、某些技术点或者是整体发展展望等分享文章</li>
</ul>
<p>在贡献不同类型的文档时，最好能够结合上面的定位对不同的内容做一些适当的裁剪，给读者最佳体验。如果是添加文档或者是投稿博客文章、添加新的文档或者调整文档目录结构请先联系团队成员。</p>
<h2 id="722-基本规范"><a class="header" href="#722-基本规范">7.2.2 基本规范</a></h2>
<ul>
<li>除标题外，内部小标题尽量带编号，便于阅读</li>
<li>工具自动输出的文档需要由到源代码的链接，小标题可以不带编号</li>
<li>尽量不要贴大段的代码（30 行以内），代码最好给出文字解释和对应的参考链接</li>
<li>有图有真相，但是不推荐过度复杂的架构图</li>
</ul>
<p><strong>标点和空格</strong></p>
<ul>
<li>在中文的文档中优先使用中文的标点</li>
<li>中文和英文之间需要增加 1 个空格</li>
<li>中文和数字之间需要增加 1 个空格</li>
<li>中文使用全角标点，标点前后均不添加空格</li>
<li>英文内容使用半角标点，标点后面加 1 个空格</li>
<li>链接前后需要保留一个空格，但是段落开头和中文全角标点附近不用添加空格。</li>
</ul>
<p><strong>图片和资源文件名</strong></p>
<ul>
<li>文件名和目录名只能用数字、英文字母、下划线 <code>_</code> 和减号 <code>-</code> 组成</li>
<li>当前文档的图片放在当前目录的 images 目录下</li>
<li>矢量图片可以通过 <a href="https://github.com/jgraph/drawio-desktop/releases">drawio 离线版</a> 绘制（并同时提交源文件），以 200% 分辨率导出 png 格式图片</li>
<li>矢量图也可以通过 <a href="https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid">Mermaid</a> 在 Markdown 中直接绘制</li>
</ul>
<h2 id="723-使用文档内容的基本模式"><a class="header" href="#723-使用文档内容的基本模式">7.2.3 使用文档内容的基本模式</a></h2>
<p>每个使用文档可以看作是一个相对完整的分享或博客文章（参考手册不再此类）。使用文档遵循以下模式组织内容：</p>
<ol>
<li>概览：本文希望解决什么问题，达到什么效果，可以先放最终效果截图</li>
<li>依赖的环境：需要安装什么工具，并给出相关链接</li>
<li>引入本文构建资源的关系图或架构图
<ul>
<li>需要用到的 Konfig 模型，给出模型参考页面链接，以及对应的上游原始模型的文档链接</li>
</ul>
</li>
<li>具体的操作步骤
<ul>
<li>尽量确保最小化代码，甚至可以刻意隐藏一些干扰代码，同时给出完整代码对应的链接</li>
<li>列出每个步骤命令的概要输出信息，并配以文字描述</li>
</ul>
</li>
<li>给出测试方式
<ul>
<li>尽量采用社区通用的方式（比如 kube、curl 命令、或浏览器）测试</li>
<li>给出测试结果的截图（和开头呼应）</li>
</ul>
</li>
<li>总结和展望
<ul>
<li>简单回顾当前操作的流程，以及一些可以展开的地方（可以给出一些链接）</li>
</ul>
</li>
</ol>
<h2 id="724-测试和提交-pr"><a class="header" href="#724-测试和提交-pr">7.2.4 测试和提交 PR</a></h2>
<p>先克隆文档仓库，本地通过 <code>npm run start</code> 和 <code>npm run build</code> 命令测试查看效果，可以参考 <a href="https://kusionstack.io/docs/develop/build-docs">构建文档</a>。确保可以正常浏览后提交 PR 即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="73-贡献代码"><a class="header" href="#73-贡献代码">7.3 贡献代码</a></h1>
<p>欢迎参与 Kusion 共建贡献完善代码、完善代码文档和测试，同时也欢迎通过 Issue 提供反馈。本文主要针对修改和完善已有的代码，如果是要增加 Konfig 新模型请先通过 Issue 或讨论中充分讨论，如果是希望增加 KCL 语言请通过 <a href="https://kusionstack.io/docs/develop/kep/">KEP</a> 流程提交。</p>
<h2 id="731-代码和注释中的错别字"><a class="header" href="#731-代码和注释中的错别字">7.3.1 代码和注释中的错别字</a></h2>
<p>如果只是修改代码和注释中的错别字，不涉及代码逻辑的调整，那么可以直接在 Github 克隆仓库后直接修改并提交 PR。需要注意的是尽量保持代码风格一致。</p>
<h2 id="732-如何贡献-konfig-模型库代码"><a class="header" href="#732-如何贡献-konfig-模型库代码">7.3.2 如何贡献 Konfig 模型库代码</a></h2>
<ul>
<li>先确保本地测试环境正常</li>
<li>修改代码并补充测试</li>
<li>本地测试通过后提交 PR</li>
</ul>
<h2 id="733-如何贡献-kusionctl-代码"><a class="header" href="#733-如何贡献-kusionctl-代码">7.3.3 如何贡献 KusionCtl 代码</a></h2>
<ul>
<li>先确保本地测试环境正常</li>
<li>修改代码并补充测试</li>
<li>本地测试通过后提交 PR</li>
</ul>
<h2 id="734-如何贡献-kclvm-代码"><a class="header" href="#734-如何贡献-kclvm-代码">7.3.4 如何贡献 KCLVM 代码</a></h2>
<ul>
<li>先确保本地测试环境正常</li>
<li>修改代码并补充测试</li>
<li>本地测试通过后提交 PR</li>
</ul>
<h2 id="735-如何贡献-vs-code-插件代码"><a class="header" href="#735-如何贡献-vs-code-插件代码">7.3.5 如何贡献 VS Code 插件代码</a></h2>
<p>请参考 VS Code 插件仓库的相关文档</p>
<h2 id="736-开发流程相关代码"><a class="header" href="#736-开发流程相关代码">7.3.6 开发流程相关代码</a></h2>
<p>欢迎通过 Issue 和讨论组讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>附录包含了常见概念说明、KCL 常见的用法和和一些参考链接。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-a-faq"><a class="header" href="#附录-a-faq">附录 A: FAQ</a></h1>
<h2 id="a1-概念--定义"><a class="header" href="#a1-概念--定义">A.1 概念 &amp; 定义</a></h2>
<h2 id="a11-kusion"><a class="header" href="#a11-kusion">A.1.1 Kusion</a></h2>
<p>F<strong>usion</strong> Cloud Native on <strong>K</strong>ubernetes. Kusion 一词来源于 fusion（意为融合） + kubernetes，是基于云原生基础设施，通过定义云原生可编程接入层，提供包括配置语言、模型界面、自动化工具、最佳实践在内的一整套解决方案，连通云原生基础设施与业务应用，连接定义和使用基础设施的各个团队，串联应用生命周期的研发、测试、集成、发布各个阶段，服务于云原生自动化系统建设，加速云原生落地。我们平时提到 Kusion，一般是对这一整套解决方案的统称；而 Kusion 生态工具链则包含了 kcl 命令行工具、KusionCtl 命令行工具、KCL IDE 插件等贯穿 Kusion 解决方案各个部分的自动化工具。</p>
<h2 id="a12-大写的-kcl-语言"><a class="header" href="#a12-大写的-kcl-语言">A.1.2 大写的 KCL 语言</a></h2>
<p><strong>K</strong>usion <strong>C</strong>onfiguration <strong>L</strong>anguage. 是由云原生工程化系统团队设计和研发的<strong>专用于配置定义、校验的动态强类型配置语言</strong>，重点服务于配置（configuration）&amp; 策略（policy programing）场景，以服务云原生配置系统为设计目标，但作为一种配置语言不限于云原生领域。KCL 吸收了声明式、OOP 编程范式的理念设计，针对云原生配置场景进行了大量优化和功能增强。KCL 最初受 Python3 脚本语言启发，依托 Python 的语言生态，目前已经发展为独立的面向配置策略的语言。</p>
<h2 id="a13-小写的-kcl-命令"><a class="header" href="#a13-小写的-kcl-命令">A.1.3 小写的 kcl 命令</a></h2>
<p><a href="https://kusionstack.io/docs/reference/cli/kcl/overview">kcl</a> 命令行工具。一般使用全大写字母的 KCL 代指 KCL 语言，而用全小写的 kcl 代指能将 KCL 代码编译为低层次数据输出（如 YAML, JSON 等）的 kcl 命令行工具。</p>
<h2 id="a14-kclvm"><a class="header" href="#a14-kclvm">A.1.4 KCLVM</a></h2>
<p><strong>V</strong>irtual <strong>M</strong>achine to parse and compile KCL。指开发 kcl 命令行工具的工程项目，也是 kcl 命令行工具的代码仓库名称，KCLVM 使用 Python、Rust 等多种语言混合开发。</p>
<h2 id="a15-kusionctl"><a class="header" href="#a15-kusionctl">A.1.5 KusionCtl</a></h2>
<p>Kusion Kubernetes Client。<a href="https://kusionstack.io/docs/reference/cli/kusionctl">KusionCtl</a> 命令行工具旨在简化用户对 K8S 的使用，内置支持对 KCL 的编译、通过登录功能原生支持 Identity 能力，支持多集群访问，提供资源状态汇总及相应的白屏展示、对用户变更模型及其关联模型的变更追踪、链路可视化、live 对比、关键资源可视化、异常定位等功能。</p>
<h2 id="a16-konfig"><a class="header" href="#a16-konfig">A.1.6 Konfig</a></h2>
<p><strong>K</strong>usion <strong>C</strong>onfig. Konfig 是一个 KCL 代码仓库，其中组织了蚂蚁域内各应用的基础设施配置。依据团队协同的层次，Konfig 仓库划分为&quot;基础配置代码&quot;和&quot;业务配置代码&quot;两部分，采用主干开发、分支发布的分支策略。</p>
<h2 id="a2-语言设计"><a class="header" href="#a2-语言设计">A.2 语言设计</a></h2>
<h3 id="a21-过程式的-for-循环"><a class="header" href="#a21-过程式的-for-循环">A.2.1 过程式的 for 循环</a></h3>
<p>KCL 中为何不支持过程式的 for 循环！</p>
<p>KCL 提供了推导表达式以及 all/any/map/filter 表达式等用于对一个集合元素进行处理，满足大部分需求，提供过程式的 for 循环体从目前场景看需求暂时不强烈，因此暂未提供过程式的 for 循环支持</p>
<p>此外，KCL 中虽然没有支持过程式的 for 循环，但是可以通过 for 循环和 lambda 函数“构造”相应的过程式 for 循环</p>
<pre><code class="language-python">result = [(lambda x: int, y: int -&gt; int {
    # 在其中书写过程式的 for 循环逻辑
    z = x + y
    x * 2
})(x, y) for x in [1, 2] for y in [1, 2]]  # [2, 2, 4, 4]
</code></pre>
<h3 id="a22-默认变量不可变"><a class="header" href="#a22-默认变量不可变">A.2.2 默认变量不可变</a></h3>
<p>KCL 变量不可变性是指 KCL 顶层结构中的非下划线 <code>_</code> 开头的导出变量初始化后不能被改变。</p>
<pre><code class="language-python">schema Person:
    name: str
    age: int

a = 1  # a会输出到YAML中，一旦赋值不可修改
_b = 1  # _b变量以下划线开头命名，不会输出到YAML中, 可多次赋值修改
_b = 2
alice = Person {
    name = &quot;Alice&quot;
    age = 18
}
</code></pre>
<p>规定变量不可变的方式分为两类：</p>
<ul>
<li>schema 外的非下划线顶层变量</li>
</ul>
<pre><code class="language-python">a = 1  # 不可变导出变量
_b = 2  # 可变非导出变量
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-b-kcl-语法"><a class="header" href="#附录-b-kcl-语法">附录 B: KCL 语法</a></h1>
<h2 id="b1-如何用-kcl-写一个简单的-key-value-对配置"><a class="header" href="#b1-如何用-kcl-写一个简单的-key-value-对配置">B.1. 如何用 KCL 写一个简单的 key-value 对配置</a></h2>
<p>创建一个名为 <code>config.k</code> 的文件</p>
<pre><code class="language-python">cpu = 256
memory = 512
image = &quot;nginx:1.14.2&quot;
service = &quot;my-service&quot;
</code></pre>
<p>上述 KCL 代码中，定义了 4 个变量 <code>cpu</code> 和 <code>memory</code> 被声明为整数类型，并且它们的值为 <code>256</code> 和 <code>512</code>，而 <code>image</code> 和 <code>service</code> 是字符串类型，它们的值为 <code>image</code> 和 <code>service</code></p>
<p>使用如下命令可以将上述 KCL 文件编译为 YAML 进行输出</p>
<pre><code>kcl config.k
</code></pre>
<p>得到的 YAML 输出为:</p>
<pre><code class="language-yaml">cpu: 256
memory: 512
image: nginx:1.14.2
service: my-service
</code></pre>
<p>如果想要输出到文件，可以使用 <code>-o|--output</code> 参数:</p>
<pre><code>kcl config.k -o config.yaml
</code></pre>
<h2 id="b2-kcl-中有哪些基本的数据类型"><a class="header" href="#b2-kcl-中有哪些基本的数据类型">B.2. KCL 中有哪些基本的数据类型？</a></h2>
<p>KCL 目前的基本数值类型和值包含:</p>
<ul>
<li>整数类型 <code>int</code>
<ul>
<li>举例: 十进制正整数 <code>1</code>, 十进制负整数 <code>-1</code>, 十六进制整数 <code>0x10</code>, 八进制整数 <code>0o10</code>, 二进制整数 <code>0b10</code></li>
</ul>
</li>
<li>浮点数类型 <code>float</code>
<ul>
<li>举例: 正浮点数 <code>1.10</code>, <code>1.0</code>, 负浮点数 <code>-35.59</code>, <code>-90.</code>, 科学记数法浮点数 <code>32.3e+18</code>, <code>70.2E-12</code></li>
</ul>
</li>
<li>布尔类型 <code>bool</code>
<ul>
<li>举例: 真值 <code>True</code>, 假值 <code>False</code></li>
</ul>
</li>
<li>字符串类型 <code>str</code> - 使用引号 <code>'</code>, <code>&quot;</code> 标记
<ul>
<li>举例: 双引号字符串 <code>&quot;string&quot;</code>, <code>&quot;&quot;&quot;string&quot;&quot;&quot;</code>, 单引号字符串 <code>'string'</code>, <code>'''string'''</code></li>
</ul>
</li>
<li>列表类型 <code>list</code> - 使用 <code>[</code>, <code>]</code> 标记
<ul>
<li>举例: 空列表 <code>[]</code>, 字符串列表 <code>[&quot;string1&quot;, &quot;string2&quot;, &quot;string3&quot;]</code></li>
</ul>
</li>
<li>字典类型 <code>dict</code> - 使用 <code>{</code>, <code>}</code> 标记
<ul>
<li>举例: 空字典 <code>{}</code>, 键值均为字符串类型的字典 <code>{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}</code></li>
</ul>
</li>
<li>结构类型 <code>schema</code> - 使用关键字 <code>schema</code> 定义，并使用相应的 schema 名称进行实例化</li>
<li>空值类型 <code>None</code> - 用于表示一个变量的值为空，与输出 YAML 的 <code>null</code> 值对应</li>
<li>未定义值类型 <code>Undefined</code> - 用于表示一个变量未被赋值，值为 <code>Undefined</code> 的变量不会被输出到 YAML 中</li>
</ul>
<pre><code class="language-python">schema Person:
    name: str
    age: int

alice = Person {
    name = &quot;Alice&quot;
    age = 18
}
bob = Person {
    name = &quot;Bob&quot;
    age = 10
}
</code></pre>
<p>注意: 所有 KCL 类型的变量均可赋值为空值 <code>None</code> 和未定义的值 <code>Undefined</code></p>
<h2 id="b3-有些-kcl-变量名带-_-下划线前缀表示什么和不带-_-下划线前缀的区别是什么分别适合什么场景下使用"><a class="header" href="#b3-有些-kcl-变量名带-_-下划线前缀表示什么和不带-_-下划线前缀的区别是什么分别适合什么场景下使用">B.3. 有些 KCL 变量名带 <code>_</code> 下划线前缀表示什么？和不带 <code>_</code> 下划线前缀的区别是什么？分别适合什么场景下使用？</a></h2>
<p>KCL 中带下划线前缀的变量表示一个<strong>隐藏</strong>的，<strong>可变</strong>的变量，<strong>隐藏</strong>表示带下划线前缀的变量不会被输出到 YAML 当中，包括包级别的下划线前缀变量和 schema 当中的下划线前缀变量。<strong>可变</strong>表示带下划线前缀的变量可被多次重复赋值，不带下划线前缀的变量被赋值后不可变。</p>
<p>带 <code>_</code> 下划线前缀的变量与不带 <code>_</code> 下划线前缀变量的区别是: 不带 <code>_</code> 下划线前缀变量默认是导出到 YAML 当中的，并且具有强不可变性；带 <code>_</code> 下划线前缀变量是不导出的，可变的。</p>
<pre><code class="language-python">name = 'Foo' # 导出变量，不可变变量
name = 'Bar' # 错误：导出变量只能设置一次
</code></pre>
<pre><code class="language-python">_name = 'Foo' # 隐藏变量，可变变量
_name = 'Bar'

schema Person:
    _name: str # hidden and mutable
</code></pre>
<h2 id="b4-如何向-dict-中添加元素"><a class="header" href="#b4-如何向-dict-中添加元素">B.4. 如何向 dict 中添加元素？</a></h2>
<p>可以使用 union 运算符 <code>|</code>, 或者 dict 解包运算符 <code>**</code> 来向 dict 中添加一个元素，并且可以使用 <code>in</code>,<code>not in</code> 等关键字判断 dict 变量当中是否包含某一个键值</p>
<pre><code class="language-python">_left = {key = {key1 = &quot;value1&quot;}, intKey = 1}  # 注意使用 = 表示覆盖
_right = {key = {key2 = &quot;value2&quot;}, intKey = 2}
dataUnion = _left | _right  # {&quot;key&quot;: {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}, &quot;intKey&quot;: 2}
dataUnpack = {**_left, **_right}  # {&quot;key&quot;: {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}, &quot;intKey&quot;: 2}
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">dataUnion:
  key:
    key1: value1
    key2: value2
dataUnpack:
  key:
    key2: value2
</code></pre>
<p>此外还可以使用 <code>字符串插值</code> 或者字符串 <code>format</code> 成员函数特性向 kcl dict 添加变量键值对</p>
<pre><code class="language-python">dictKey1 = &quot;key1&quot;
dictKey2 = &quot;key2&quot;
data = {
    &quot;${dictKey1}&quot; = &quot;value1&quot;
    &quot;{}&quot;.format(dictKey2) = &quot;value2&quot;
}
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">dictKey1: key1
dictKey2: key2
data:
  key1: value1
  key2: value2
</code></pre>
<h2 id="b5-如何修改-dict-中的元素"><a class="header" href="#b5-如何修改-dict-中的元素">B.5. 如何修改 dict 中的元素？</a></h2>
<p>与问题<a href="appendix/b-kcl.html#3-%E5%A6%82%E4%BD%95%E5%90%91-dict-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0">如何向 dict 中添加元素？</a>类似，可以使用 union 运算符 <code>|</code>, 或者解包运算符 <code>**</code> 修改 dict 当中的元素</p>
<pre><code class="language-python">_data = {key = &quot;value&quot;}  # {&quot;key&quot;: &quot;value&quot;}
_data = _data | {key = &quot;override_value1&quot;}  # {&quot;key&quot;: &quot;override_value1&quot;}
_data = {**_data, **{key = &quot;override_value2&quot;}}  # {&quot;key&quot;: &quot;override_value2&quot;}
</code></pre>
<p>如果想要删除 dict 中某个键为 <code>key</code> 的值，可以使用解包运算符 <code>**{key = Undefined}</code> 或者合并运算符 <code>| {key = Undefined}</code> 进行覆盖，覆盖后 key 的值为 Undefined，不会进行 YAML 输出。</p>
<h2 id="b6-如何向-list-中添加元素"><a class="header" href="#b6-如何向-list-中添加元素">B.6. 如何向 list 中添加元素？</a></h2>
<p>在 list 中添加元素有两种方式：</p>
<ul>
<li>使用 <code>+</code>, <code>+=</code> 和 slice 切片连接组装 list 变量达到向 list 中添加元素的目的</li>
</ul>
<pre><code class="language-python">_args = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
_args += [&quot;end&quot;]  # 在list尾部添加元素&quot;end&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;end&quot;]
_args = _args[:2] + [&quot;x&quot;] + _args[2:]  # 在list索引为2的地方插入元素&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;c&quot;, &quot;end&quot;]
_args = [&quot;start&quot;] + _args  # 在list头部添加元素&quot;start&quot;, [&quot;start&quot;, &quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;c&quot;, &quot;end&quot;]
</code></pre>
<ul>
<li>使用 <code>*</code> 解包运算符连接合并 list</li>
</ul>
<pre><code class="language-python">_args = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
_args = [*_args, &quot;end&quot;]  # 在list尾部添加元素&quot;end&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;end&quot;]
_args = [&quot;start&quot;, *_args]  # 在list头部添加元素&quot;start&quot;, [&quot;start&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;end&quot;]
</code></pre>
<p>注意：当接连的变量为 <code>None/Undefined</code> 时，使用 <code>+</code> 可能会发生错误，这时使用 list 解包运算符 <code>*</code> 或者使用 <code>or</code> 运算符取 list 的默认值可以避免空值判断</p>
<pre><code class="language-python">data1 = [1, 2, 3]
data2 = None
data3 = [*data1, *data2]  # Right [1, 2, 3]
data4 = data1 + data2 or [] # Right [1, 2, 3], 使用 or 取 data2 的默认值为 []， 当 data2 为 None/Undefined 时，取空列表 [] 进行计算
data5 = data1 + data2  # Error: can only concatenate list (not &quot;NoneType&quot;) to list
</code></pre>
<h2 id="b7-如何修改删除-list-中的元素"><a class="header" href="#b7-如何修改删除-list-中的元素">B.7. 如何修改/删除 list 中的元素？</a></h2>
<p>修改 list 中的元素分为两种方式：</p>
<ul>
<li>直接修改 list 某个索引处的值，使用 slice 切片</li>
</ul>
<pre><code class="language-python">_index = 1
_args = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
_args = _args[:index] + [&quot;x&quot;] + _args[index+1:]  # 修改list索引为1的元素为&quot;x&quot;, [&quot;a&quot;, &quot;x&quot;, &quot;c&quot;]
</code></pre>
<ul>
<li>根据某个条件修改 list 当中的元素，使用 list comprehension 列表推导式</li>
</ul>
<pre><code class="language-python">_args = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
_args = [&quot;x&quot; if a == &quot;b&quot; else a for a in _args]  # 将list当中值为&quot;b&quot;的值都修改为&quot;x&quot;, [&quot;a&quot;, &quot;x&quot;, &quot;c&quot;]
</code></pre>
<p>删除 list 中的元素分为两种方式：</p>
<ul>
<li>使用 list for 推导表达式中 if 过滤条件</li>
<li>使用 filter 表达式对 list 进行元素过滤</li>
</ul>
<p>比如想要删除一个列表 <code>[1, 2, 3, 4, 5]</code> 中大于 2 的数字，则在 KCL 中可以写为:</p>
<pre><code class="language-python">originList = [1, 2, 3, 4, 5]
oneWayDeleteListItem = [item for item in originList if item &lt;= 2]
anotherWayDeleteListItem = filter item in originList {
    item &lt;= 2
}
</code></pre>
<p>输出如下结果</p>
<pre><code class="language-yaml">originList:
- 1
- 2
- 3
- 4
- 5
oneWayDeleteListItem:
- 1
- 2
anotherWayDeleteListItem:
- 1
- 2
</code></pre>
<h2 id="b8-怎样写-for-循环怎样理解和使用-list-comprehension-列表推导式-和-dict-comprehension-字典推导式-"><a class="header" href="#b8-怎样写-for-循环怎样理解和使用-list-comprehension-列表推导式-和-dict-comprehension-字典推导式-">B.8. 怎样写 for 循环？怎样理解和使用 list comprehension 列表推导式 和 dict comprehension 字典推导式 ？</a></h2>
<p>KCL 目前仅支持函数式/声明式的推导式 for 循环方式，可以按照如下方式遍历 dict 和 list 变量:</p>
<p>list 推导式具体形式为(其中推导式两边使用方括号 <code>[]</code>):</p>
<pre><code class="language-txt">[expression for expr in sequence1
            if condition1
            for expr2 in sequence2
            if condition2
            for expr3 in sequence3 ...
            if condition3
            for exprN in sequenceN
            if conditionN]
</code></pre>
<p>dict 推导式具体形式为(其中推导式两边使用花括号 <code>{}</code>):</p>
<pre><code class="language-txt">{expression for expr in sequence1
            if condition1
            for expr2 in sequence2
            if condition2
            for expr3 in sequence3 ...
            if condition3
            for exprN in sequenceN
            if conditionN}
</code></pre>
<p>上述推导式中的 <code>if</code> 表示过滤条件，满足条件的表达式 <code>expr</code> 才会生成到新的 list 或 dict 中</p>
<p>list 推导式举例:</p>
<pre><code class="language-python">_listData = [1, 2, 3, 4, 5, 6]
_listData = [l * 2 for l in _listData]  # _listData中所有元素都乘以2，[2, 4, 6, 8, 10, 12]
_listData = [l for l in _listData if l % 4 == 0]  # 筛选出_listData中可以被4整除的所有元素，[4, 8, 12]
_listData = [l + 100 if l % 8 == 0 else l for l in _listData]  # 遍历_listData, 当其中的元素可以被8整除时，将该元素加100，否则保持不变, [4, 108, 12]
</code></pre>
<p>注意上述代码中第 3 行和第 4 行两个 <code>if</code> 的区别:</p>
<ul>
<li>第一个 <code>if</code> 表示 list 变量 <code>_listData</code> 本身的推导式过滤条件，后不能跟 <code>else</code>，满足该过滤条件的元素会继续放在该列表中，不满足条件的元素被剔除，有可能会使列表长度发生变化</li>
<li>第二个 <code>if</code> 表示 list 迭代变量 <code>l</code> 的选择条件，表示 <code>if-else</code> 三元表达式，后必须跟 <code>else</code>，不论是否满足该条件，产生的元素仍然在该列表中，列表长度不变</li>
</ul>
<p>dict 推导式举例:</p>
<pre><code class="language-python">_dictData = {key1 = &quot;value1&quot;, key2 = &quot;value2&quot;}
_dictData = {k = _dictData[k] for k in _dictData if k == &quot;key1&quot; and _dictData[k] == &quot;value1&quot;}  # 将_dictData中key为&quot;key1&quot;, value为&quot;value1&quot;的元素筛选出来, {&quot;key1&quot;: &quot;value1&quot;}
</code></pre>
<p>使用推导式获得 dict 所有 key:</p>
<pre><code class="language-python">dictData = {key1 = &quot;value1&quot;, key2 = &quot;value2&quot;}
dictDataKeys = [k for k in _dictData]  # [&quot;key1&quot;, &quot;key2&quot;]
</code></pre>
<p>使用推导式对 dict 按照 key 的字典序升序进行排序:</p>
<pre><code class="language-python">dictData = {key3 = &quot;value3&quot;, key2 = &quot;value2&quot;, key1 = &quot;value1&quot;}  # {'key3': 'value3', 'key2': 'value2', 'key1': 'value1'}
dictSortedData = {k = dictData[k] for k in sorted(dictData)}  # {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}
</code></pre>
<p>多级推导式举例:</p>
<pre><code class="language-python">array1 = [1, 2, 3]
array2 = [4, 5, 6]
data = [a1 + a2 for a1 in array1 for a2 in array2]  # [5, 6, 7, 6, 7, 8, 7, 8, 9] len(data) == len(array1) * len(array2)
</code></pre>
<p>双变量循环(for 推导表达式支持 list 的索引迭代以及 dict 的 value 迭代，可以简化 list/dict 迭代过程代码书写):</p>
<ul>
<li>list</li>
</ul>
<pre><code class="language-python">data = [1000, 2000, 3000]
# 单变量循环
dataLoop1 = [i * 2 for i in data]  # [2000, 4000, 6000]
dataLoop2 = [i for i in data if i == 2000]  # [2000]
dataLoop3 = [i if i &gt; 2 else i + 1 for i in data]  # [1000, 2000, 3000]
# 双变量循环
dataLoop4 = [i + v for i, v in data]  # [1000, 2001, 3002]
dataLoop5 = [v for i, v in data if v == 2000]  # [2000]
# 使用_忽略循环变量
dataLoop6 = [v if v &gt; 2000 else v + i for i, v in data]  # [1000, 2001, 3000]
dataLoop7 = [i for i, _ in data]  # [0, 1, 2]
dataLoop8 = [v for _, v in data if v == 2000]  # [2000]
</code></pre>
<ul>
<li>dict</li>
</ul>
<pre><code class="language-python">data = {key1 = &quot;value1&quot;, key2 = &quot;value2&quot;}
# 单变量循环
dataKeys1 = [k for k in data]  # [&quot;key1&quot;, &quot;key2&quot;]
dataValues1 = [data[k] for k in data]  # [&quot;value1&quot;, &quot;value2&quot;]
# 双变量循环
dataKeys2 = [k for k, v in data]  # [&quot;key1&quot;, &quot;key2&quot;]
dataValues2 = [v for k, v in data]  # [&quot;value1&quot;, &quot;value2&quot;]
dataFilter = {k = v for k, v in data if k == &quot;key1&quot; and v == &quot;value1&quot;}  # {&quot;key1&quot;: &quot;value1&quot;}
# 使用_忽略循环变量
dataKeys3 = [k for k, _ in data]  # [&quot;key1&quot;, &quot;key2&quot;]
dataValues3 = [v for _, v in data]  # [&quot;value1&quot;, &quot;value2&quot;]
</code></pre>
<h2 id="b9-怎样写-if-条件语句"><a class="header" href="#b9-怎样写-if-条件语句">B.9. 怎样写 if 条件语句？</a></h2>
<p>KCL 支持两种方式书写 if 条件语句:</p>
<ul>
<li>if-elif-else 块语句，其中 elif 和 else 块均可省略，并且 elif 块可以使用多次</li>
</ul>
<pre><code class="language-python">success = True
_result = &quot;failed&quot;
if success:
    _result = &quot;success&quot;
</code></pre>
<pre><code class="language-python">success = True
if success:
    _result = &quot;success&quot;
else:
    _result = &quot;failed&quot;
</code></pre>
<pre><code class="language-python">_result = 0
if condition == &quot;one&quot;:
    _result = 1
elif condition == &quot;two&quot;:
    _result = 2
elif condition == &quot;three&quot;:
    _result = 3
else:
    _result = 4
</code></pre>
<ul>
<li>条件表达式 <code>&lt;expr1&gt; if &lt;condition&gt; else &lt;expr2&gt;</code>, 类似于 C 语言当中的 <code>&lt;condition&gt; ? &lt;expr1&gt; : &lt;expr2&gt;</code> 三元表达式</li>
</ul>
<pre><code class="language-python">success = True
_result = &quot;success&quot; if success else &quot;failed&quot;
</code></pre>
<p>注意：在书写 if-elif-else 块语句时注意书写 if 条件后的冒号 <code>:</code> 以及保持缩进的统一</p>
<p>除此之外，还可以在 list 或者 dict 结构中直接书写条件表达式(不同的是，在结构中书写的 if 表达式中需要书写的值而不是语句):</p>
<ul>
<li>list</li>
</ul>
<pre><code class="language-python">env = &quot;prod&quot;
data = [
    &quot;env_value&quot;
    &quot;:&quot;
    if env == &quot;prod&quot;:
        &quot;prod&quot;  # 书写需要添加到 data 中的值，而不是语句
    else:
        &quot;other_prod&quot;
]  # [&quot;env_value&quot;, &quot;:&quot;, &quot;prod&quot;]
</code></pre>
<ul>
<li>dict</li>
</ul>
<pre><code class="language-python">env = &quot;prod&quot;
config = {
    if env == &quot;prod&quot;:
        MY_PROD_ENV = &quot;prod_value&quot; # 书写需要添加到 config 中的键-值对，而不是语句
    else:
        OTHER_ENV = &quot;other_value&quot;
}  # {&quot;MY_PROD_ENV&quot;: &quot;prod_value&quot;}
</code></pre>
<h2 id="b10-怎样表达-与-或-非-等逻辑运算"><a class="header" href="#b10-怎样表达-与-或-非-等逻辑运算">B.10. 怎样表达 &quot;与&quot; &quot;或&quot; &quot;非&quot; 等逻辑运算？</a></h2>
<p>在 KCL 中，使用 <code>and</code> 表示&quot;逻辑与&quot;, 使用 <code>or</code> 表示&quot;逻辑或&quot;, 使用 <code>not</code> 表示&quot;非&quot;, 与 C 语言当中的 <code>&amp;&amp;</code>, <code>||</code> 和 <code>~</code> 语义一致；</p>
<pre><code class="language-python">done = True
col == 0
if done and (col == 0 or col == 3):
    ok = 1
</code></pre>
<p>对于整数的&quot;按位与&quot;, &quot;按位或&quot;和&quot;按位异或&quot;，在 KCL 中使用 <code>&amp;</code>, <code>|</code> 和 <code>^</code> 运算符表示, 与 C 语言当中的 <code>&amp;</code>, <code>|</code> 和 <code>^</code> 语义一致；</p>
<pre><code class="language-python">value = 0x22
bitmask = 0x0f

assert (value &amp; bitmask) == 0x02
assert (value &amp; ~bitmask) == 0x20
assert (value | bitmask) == 0x2f
assert (value ^ bitmask) == 0x2d
</code></pre>
<p>&quot;逻辑或&quot; <code>or</code> 的妙用：当需要书写诸如 <code>A if A else B</code> 类似的模式时，可以使用 <code>A or B</code> 进行简化，比如如下代码:</p>
<pre><code class="language-python">value = [0]
default = [1]
x0 = value if value else default
x1 = value or default  # 使用 value or default 代替 value if value else default
</code></pre>
<h2 id="b11-如何判断变量是否为-noneundefined字符串dictlist-是否为空"><a class="header" href="#b11-如何判断变量是否为-noneundefined字符串dictlist-是否为空">B.11. 如何判断变量是否为 None/Undefined、字符串/dict/list 是否为空？</a></h2>
<p>请注意，在 if 表达式的条件判断中，<code>False</code>、<code>None</code>、<code>Undefined</code>、数字 <code>0</code>、空列表 <code>[]</code>、空字典 <code>{}</code> 和空字符串 <code>&quot;&quot;</code>, <code>''</code>, <code>&quot;&quot;&quot;&quot;&quot;&quot;</code>, <code>''''''</code> 都被视为值为 <code>假</code> 的表达式。</p>
<p>比如判断一个字符串变量 <code>strData</code> 既不为 <code>None/Undefined</code> 也不为空字符串时(字符串长度大于 0)，就可以简单的使用如下表达式:</p>
<pre><code class="language-python">strData = &quot;value&quot;
if strData:
    isEmptyStr = False
</code></pre>
<p>空字典和空列表判断举例:</p>
<pre><code class="language-python">_emptyList = []
_emptyDict = {}
isEmptyList = False if _emptyList else True
isEmptyDict = False if _emptyDict else True
</code></pre>
<p>YAML 输出为:</p>
<pre><code class="language-yaml">isEmptyList: true
isEmptyDict: true
</code></pre>
<p>或者使用布尔函数 <code>bool</code> 进行判断</p>
<pre><code class="language-python">_emptyList = []
_emptyDict = {}
isEmptyList = bool(_emptyList)
isEmptyDict = bool(_emptyDict)
</code></pre>
<h2 id="b12-字符串怎样拼接怎样格式化字符串怎样检查字符串前缀后缀怎样替换字符串内容"><a class="header" href="#b12-字符串怎样拼接怎样格式化字符串怎样检查字符串前缀后缀怎样替换字符串内容">B.12. 字符串怎样拼接、怎样格式化字符串、怎样检查字符串前缀、后缀？怎样替换字符串内容？</a></h2>
<ul>
<li>KCL 中可以使用 <code>+</code> 运算符连接两个字符串</li>
</ul>
<pre><code class="language-python">data1 = &quot;string1&quot; + &quot;string2&quot;  # &quot;string1string2&quot;
data2 = &quot;string1&quot; + &quot; &quot; + &quot;string2&quot;  # &quot;string1 string2&quot;
</code></pre>
<ul>
<li>KCL 中目前存在两种格式化字符串的方式:
<ul>
<li>字符串变量的 format 方法 <code>&quot;{}&quot;.format()</code></li>
<li>字符串插值 <code>${}</code></li>
</ul>
</li>
</ul>
<pre><code class="language-python">hello = &quot;hello&quot;
a = &quot;{} world&quot;.format(hello)
b = &quot;${hello} world&quot;
# a,b 均被赋值为&quot;hello world&quot;
</code></pre>
<p>注意，如果想在 <code>&quot;{}&quot;.format()</code> 中单独使用 <code>{</code> 字符或者 <code>}</code>, 则需要使用 <code>{{</code> 和 <code>}}</code> 分别对 <code>{</code> 和 <code>}</code> 进行转义，比如转义一个 JSON 字符串如下代码：</p>
<pre><code class="language-python">data = &quot;value&quot;
jsonData = '{{&quot;key&quot;: &quot;{}&quot;}}'.format(data)
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">data: value
jsonData: '{&quot;key&quot;: &quot;value&quot;}'
</code></pre>
<p>注意，如果想在 <code>${}</code> 插值字符串中单独使用 <code>$</code> 字符，则需要使用 <code>$$</code> 对 <code>$</code> 进行转义</p>
<pre><code class="language-python">world = &quot;world&quot;
a = &quot;hello {}&quot;.format(world)       # &quot;hello world&quot;
b = &quot;hello ${world}&quot;               # &quot;hello world&quot;
c = &quot;$$hello ${world}$$&quot;           # &quot;$hello world$&quot;
c2 = &quot;$&quot; + &quot;hello ${world}&quot; + &quot;$&quot;  # &quot;$hello world$&quot;
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">world: world
a: hello world
b: hello world
c: $hello world$
c2: $hello world$
</code></pre>
<ul>
<li>KCL 中使用字符串的 <code>startswith</code> 和 <code>endswith</code> 方法检查字符串的前缀和后缀</li>
</ul>
<pre><code class="language-python">data = &quot;length&quot;
isEndsWith = data.endswith(&quot;th&quot;)  # True
isStartsWith = &quot;length&quot;.startswith('len')  # True
</code></pre>
<ul>
<li>KCL 中使用字符串的 replace 方法或者 regex.replace 函数替换字符串的内容</li>
</ul>
<pre><code class="language-python">import regex
data1 = &quot;length&quot;.replace(&quot;len&quot;, &quot;xxx&quot;)  # 使用&quot;xxx&quot;替换&quot;len&quot;, &quot;xxxgth&quot;
data2 = regex.replace(&quot;abc123&quot;, r&quot;\D&quot;, &quot;0&quot;)  # 替换&quot;abc123&quot;中的所有非数字为&quot;0&quot;, &quot;000123&quot;
</code></pre>
<p>其中，<code>r&quot;\D&quot;</code> 表示不需要使用 <code>\\</code> 转义 <code>\D</code> 中的反斜杠 <code>\</code>，多用于正则表达式字符串中</p>
<p><code>regex.replace</code> 函数详细使用方式请参考:</p>
<ul>
<li><a href="appendix/b-kcl.html#14-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">如何使用正则表达式？</a></li>
</ul>
<p>此外，我们可以在字符串格式化表达式中插入索引占位符或者关键字占位符用于格式化多个字符串</p>
<ul>
<li>索引占位符</li>
</ul>
<pre><code class="language-python">x = '{2} {1} {0}'.format('directions', 'the', 'Read')
y = '{0} {0} {0}'.format('string')
</code></pre>
<p>输出为:</p>
<pre><code class="language-yaml">x: Read the directions
y: string string string
</code></pre>
<p>关键字占位符</p>
<pre><code class="language-python">x = 'a: {a}, b: {b}, c: {c}'.format(a = 1, b = 'Two', c = 12.3)
</code></pre>
<p>输出为:</p>
<pre><code class="language-yaml">x: 'a: 1, b: Two, c: 12.3'
</code></pre>
<h2 id="b13-字符串中使用单引号和双引号的区别是什么"><a class="header" href="#b13-字符串中使用单引号和双引号的区别是什么">B.13. 字符串中使用单引号和双引号的区别是什么？</a></h2>
<p>KCL 单引号和双引号字符串几乎没有区别。唯一的区别是，不需要在单引号字符串中使用 <code>\&quot;</code> 转义双引号 <code>&quot;</code>，不需要在双引号字符串中使用 <code>\'</code> 转义单引号引号 <code>'</code>。</p>
<pre><code class="language-python">singleQuotedString = 'This is my book named &quot;foo&quot;'  # Don’t need to escape double quotes in single quoted strings.
doubleQuotedString = &quot;This is my book named 'foo'&quot;  # Don’t need to escape single quotes in double quoted strings.
</code></pre>
<p>此外在 KCL 中，使用三个单引号或者三个双引号组成的长字符串，无需在其中对单引号或者三引号进行转义 (除字符串首尾)，比如如下例子：</p>
<pre><code class="language-python">longStrWithQuote0 = &quot;&quot;&quot;Double quotes in long strings &quot;(not at the beginning and end)&quot;&quot;&quot;
longStrWithQuote1 = '''Double quotes in long strings &quot;(not at the beginning and end)'''
longStrWithQuote2 = &quot;&quot;&quot;Single quotes in long strings '(not at the beginning and end)&quot;&quot;&quot;
longStrWithQuote3 = '''Single quotes in long strings '(not at the beginning and end)'''
</code></pre>
<p>输出 YAML：</p>
<pre><code class="language-yaml">longStrWithQuote0: Double quotes in long strings &quot;(not at the beginning and end)
longStrWithQuote1: Double quotes in long strings &quot;(not at the beginning and end)
longStrWithQuote2: Single quotes in long strings '(not at the beginning and end)
longStrWithQuote3: Single quotes in long strings '(not at the beginning and end)
</code></pre>
<h2 id="b14-如何编写跨行的长字符串"><a class="header" href="#b14-如何编写跨行的长字符串">B.14. 如何编写跨行的长字符串？</a></h2>
<p>KCL 中可以使用单引号字符串 + 换行符 <code>\n</code> 或者三引号字符串书写一个多行字符串，并且可以借助续行符 <code>\</code> 优化 KCL 字符串的形式，比如对于如下代码中的三个多行字符串变量，它们的制是相同的：</p>
<pre><code class="language-python">string1 = &quot;The first line\nThe second line\nThe third line\n&quot;
string2 = &quot;&quot;&quot;The first line
The second line
The third line
&quot;&quot;&quot;
string3 = &quot;&quot;&quot;\
The first line
The second line
The third line
&quot;&quot;&quot;  # 推荐使用 string3 长字符串的书写形式
</code></pre>
<p>输出 YAML 为：</p>
<pre><code class="language-yaml">string1: |
  The first line
  The second line
  The third line
string2: |
  The first line
  The second line
  The third line
string3: |
  The first line
  The second line
  The third line
</code></pre>
<h2 id="b15-如何使用正则表达式"><a class="header" href="#b15-如何使用正则表达式">B.15. 如何使用正则表达式？</a></h2>
<p>通过在 KCL 中导入正则表达式库 <code>import regex</code> 即可使用正则表达式，其中包含了如下函数:</p>
<ul>
<li><strong>match</strong>: 正则表达式匹配函数，正根正则表达式对输入字符串进行匹配，返回 bool 类型表示是否匹配成功</li>
<li><strong>split</strong>: 正则表达式分割函数，根据正则表达式分割字符串，返回分割字串的列表</li>
<li><strong>replace</strong>: 正则表达式替换函数，替换字符串中所有满足正则表达式的子串，返回被替换的字符串</li>
<li><strong>compile</strong>: 正则表达式编译函数，返回 bool 类型表示是否是一个合法的正则表达式</li>
<li><strong>search</strong>: 正则表达式搜索函数，搜索所有满足正则表达式的子串，返回子串的列表</li>
</ul>
<p>使用举例:</p>
<pre><code class="language-python">regex_source = &quot;Apple,Google,Baidu,Xiaomi&quot;
regex_split = regex.split(regex_source, &quot;,&quot;)
regex_replace = regex.replace(regex_source, &quot;,&quot;, &quot;|&quot;)
regex_compile = regex.compile(&quot;$^&quot;)
regex_search = regex.search(&quot;aaaa&quot;, &quot;a&quot;)
regex_find_all = regex.findall(&quot;aaaa&quot;, &quot;a&quot;)
regex_result = regex.match(&quot;192.168.0.1&quot;, &quot;^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;+&quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;+&quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;+&quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;)  # 判断是否是一个IP字符串
regex_result_false = regex.match(&quot;192.168.0,1&quot;, &quot;^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;+&quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;+&quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;+&quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;)  # 判断是否是一个IP字符串
</code></pre>
<p>输出 YAML:</p>
<pre><code class="language-yaml">regex_source: Apple,Google,Baidu,Xiaomi
regex_split:
- Apple
- Google
- Baidu
- Xiaomi
regex_replace: Apple|Google|Baidu|Xiaomi
regex_compile: true
regex_search: true
regex_find_all:
- a
- a
- a
- a
regex_result: true
regex_result_false: false
</code></pre>
<p>对于比较长的正则表达式，还可以使用 r-string 忽略 <code>\</code> 符号的转义简化正则表达式字符串的书写:</p>
<pre><code class="language-python">isIp = regex.match(&quot;192.168.0.1&quot;, r&quot;^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9]).&quot;+r&quot;(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d).&quot;+r&quot;(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d).&quot;+r&quot;(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$&quot;)  # 判断是否是一个IP字符串
</code></pre>
<p>更多举例:</p>
<pre><code class="language-python">import regex

schema Resource:
    cpu:         str = &quot;1&quot;
    memory:      str = &quot;1024Mi&quot;
    disk:        str = &quot;10Gi&quot;
    check:
        regex.match(cpu, r&quot;^([+-]?[0-9.]+)([m]*[-+]?[0-9]*)$&quot;), &quot;cpu must match specific regular expression&quot;
        regex.match(memory, r&quot;^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$&quot;), &quot;memory must match specific regular expression&quot;
        regex.match(disk, r&quot;^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$&quot;), &quot;disk must match specific regular expression&quot;
</code></pre>
<pre><code class="language-python">import regex

schema Env:
    name:            str
    value?:          str
    check:
        len(name) &lt;= 63, &quot;a valid env name must be no more than 63 characters&quot;
        regex.match(name, r&quot;[A-Za-z_][A-Za-z0-9_]*&quot;), &quot;a valid env name must start with alphabetic character or '_', followed by a string of alphanumeric characters or '_'&quot;
</code></pre>
<h2 id="b16-kcl-当中的-schema-是什么含义"><a class="header" href="#b16-kcl-当中的-schema-是什么含义">B.16. KCL 当中的 schema 是什么含义？</a></h2>
<p>schema 是 KCL 中一种语言元素，用于定义配置数据的类型，像 C 语言中的 struct 或者 Java 中的 class 一样，在其中可以定义属性，每种属性具有相应的类型，比如问题 <a href="appendix/b-kcl.html#17-%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E-schema-">17. 如何声明 schema</a> 当中显示的 schema 例子</p>
<h2 id="b17-如何声明-schema"><a class="header" href="#b17-如何声明-schema">B.17. 如何声明 schema？</a></h2>
<p>KCL 中使用 schema 关键字可以定义一个结构，在其中可以申明 schema 的各个属性</p>
<pre><code class="language-python"># 一个Person结构，其中具有属性字符串类型的firstName, 字符串类型的lastName, 整数类型的age
schema Person:
    firstName: str
    lastName: str
    # age属性的默认值为0
    age: int = 0
</code></pre>
<p>一个复杂例子:</p>
<pre><code class="language-python">schema Deployment:
    name: str
    cpu: int
    memory: int
    image: str
    service: str
    replica: int
    command: [str]
    labels: {str:str}
</code></pre>
<p>在上面的代码中，<code>cpu</code> 和 <code>memory</code> 被定义为整数 int 类型；<code>name</code>，<code>image</code> 和 <code>service</code> 是字符串 str 类型;
<code>command</code> 是字符串类型的列表; labels 是字典类型，其键类型和值类型均为字符串。</p>
<h2 id="b18-如何为-schema-属性添加-不可变必选-约束"><a class="header" href="#b18-如何为-schema-属性添加-不可变必选-约束">B.18. 如何为 schema 属性添加 &quot;不可变&quot;、&quot;必选&quot; 约束？</a></h2>
<p>KCL 中使用 <code>?</code> 运算符定义一个 schema 的&quot;可选&quot;约束，schema 属性默认都是&quot;必选&quot;的</p>
<pre><code class="language-python"># 一个Person结构，其中具有属性字符串类型的firstName, 字符串类型的lastName, 整数类型的age
schema Person:
    firstName?: str  # firstName是一个可选属性，可以赋值为None/Undefined
    lastName?: str  # age是一个可选属性，可以赋值为None/Undefined
    # age属性的默认值为0
    age: int = 18  # age是一个必选属性，不能赋值为None/Undefined，并且是一个不可变属性
    age = 10  # Error, age是一个不可变的属性
</code></pre>
<h2 id="b19-如何为-schema-中的属性编写校验规则"><a class="header" href="#b19-如何为-schema-中的属性编写校验规则">B.19. 如何为 schema 中的属性编写校验规则？</a></h2>
<p>在 schema 定义当中可以使用 check 关键字编写 schema 属性的校验规则, 如下所示，check 代码块中的每一行都对应一个条件表达式，当满足条件时校验成功，当不满足条件时校验失败, 条件表达式后可跟 <code>, &quot;check error message&quot;</code> 表示当校验失败时需要显示的信息</p>
<pre><code class="language-python">import regex

schema Sample:
    foo: str  # Required, 不能为None/Undefined, 且类型必须为str
    bar: int  # Required, 不能为None/Undefined, 且类型必须为int
    fooList: [int]  # Required, 不能为None/Undefined, 且类型必须为int列表
    color: &quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;  # Required, 字面值联合类型，且必须为&quot;Red&quot;, &quot;Yellow&quot;, &quot;Blue&quot;中的一个，枚举作用
    id?: int  # Optional，可以留空，类型必须为int

    check:
        bar &gt;= 0  # bar必须大于等于0
        bar &lt; 100 # bar必须小于100
        len(fooList) &gt; 0  # fooList不能为None/Undefined，并且长度必须大于0
        len(fooList) &lt; 100 # fooList不能为None/Undefined，并且长度必须小于100
        regex.match(foo, &quot;^The.*Foo$&quot;) # regex 正则表达式匹配
        bar in range(100) # range, bar范围只能为1到99
        bar in [2, 4, 6, 8] # enum, bar只能取2, 4, 6, 8
        bar % 2 == 0  # bar必须为2的倍数
        all foo in fooList {
            foo &gt; 1
        }  # fooList中的所有元素必须大于1
        any foo in fooList {
            foo &gt; 10
        }  # fooList中至少有一个元素必须大于10
        abs(id) &gt; 10 if id  # check if 表达式，当 id 不为空时，id的绝对值必须大于10
</code></pre>
<p>此外，上述 check 当中比较表达式还可以简写为:</p>
<pre><code class="language-python">0 &lt;= bar &lt; 100
0 &lt; len(fooList) &lt; 100
</code></pre>
<p>综上所述，KCL Schema 中支持的校验类型为:</p>
<table><thead><tr><th>校验类型</th><th>使用方法</th></tr></thead><tbody>
<tr><td>范围校验</td><td>使用 <code>&lt;</code>, <code>&gt;</code> 等比较运算符</td></tr>
<tr><td>正则校验</td><td>使用 <code>regex</code> 系统库中的 <code>match</code> 等方法</td></tr>
<tr><td>长度校验</td><td>使用 <code>len</code> 内置函数，可以求 <code>list/dict/str</code> 类型的变量长度</td></tr>
<tr><td>枚举校验</td><td>使用字面值联合类型</td></tr>
<tr><td>非空校验</td><td>使用 schema 的可选/必选属性</td></tr>
<tr><td>条件校验</td><td>使用 check if 条件表达式</td></tr>
</tbody></table>
<h2 id="b20-如何为-schema-及其属性添加文档注释"><a class="header" href="#b20-如何为-schema-及其属性添加文档注释">B.20. 如何为 schema 及其属性添加文档注释？</a></h2>
<p>一个完整的 schema 属性注释使用三引号字符串表示，其中的结构如下所示:</p>
<pre><code class="language-python">schema Person:
    &quot;&quot;&quot;The schema person definition

    Attributes
    ----------
    name : str
        The name of the person
    age : int
        The age of the person

    See Also
    --------
    Son:
        Sub-schema Son of the schema Person.

    Examples
    --------
    person = Person {
        name = &quot;Alice&quot;
        age = 18
    }
    &quot;&quot;&quot;
    name: str
    age: int

person = Person {
    name = &quot;Alice&quot;
    age = 18
}
</code></pre>
<h2 id="b21-如何基于-schema-编写配置多个配置之间如何复用公共的配置"><a class="header" href="#b21-如何基于-schema-编写配置多个配置之间如何复用公共的配置">B.21. 如何基于 schema 编写配置？多个配置之间如何复用公共的配置？</a></h2>
<p>在 schema 实例化的过程中可以使用解包运算符 <code>**</code> 对公共的配置进行展开</p>
<pre><code class="language-python">schema Boy:
    name: str
    age: int
    hc: int

schema Girl:
    name: str
    age: int
    hc: int

config = {
    age = 18
    hc = 10
}

boy = Boy {
    **config
    name = &quot;Bob&quot;
}
girl = Girl {
    **config
    name = &quot;Alice&quot;
}
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">config:
  age: 18
  hc: 10
boy:
  name: Bob
  age: 18
  hc: 10
girl:
  name: Alice
  age: 18
  hc: 10
</code></pre>
<h2 id="b22-基于-schema-编写配置时如何覆盖-schema-属性的默认值"><a class="header" href="#b22-基于-schema-编写配置时如何覆盖-schema-属性的默认值">B.22. 基于 schema 编写配置时如何覆盖 schema 属性的默认值？</a></h2>
<p>在定义 schema 后，可以使用 schema 名称实例化相应的配置，使用 <code>:</code> 运算符对 schema 默认值进行 union, 使用 <code>=</code> 对 schema 默认值进行覆盖。对于 int/float/bool/str 类型的 schema 属性，union 和覆盖的效果相同; 对于 list/dict/schema 类型的 schema 属性，union 和覆盖的效果不同;</p>
<pre><code class="language-python">schema Meta:
    labels: {str:str} = {&quot;key1&quot; = &quot;value1&quot;}
    annotations: {str:str} = {&quot;key1&quot; = &quot;value1&quot;}

meta = Meta {
    labels: {&quot;key2&quot;: &quot;value2&quot;}
    annotations = {&quot;key2&quot; = &quot;value2&quot;}
}
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">meta:
  labels:
    key1: value1
    key2: value2
  annotations:
    key2: value2
</code></pre>
<h2 id="b23-如何通过继承来复用-schema-定义"><a class="header" href="#b23-如何通过继承来复用-schema-定义">B.23. 如何通过继承来复用 schema 定义？</a></h2>
<p>可以在 schema 定义处声明 schema 需要继承的 schema 名称:</p>
<pre><code class="language-python"># A person has a first name, a last name and an age.
schema Person:
    firstName: str
    lastName: str
    # The default value of age is 0
    age: int = 0

# An employee **is** a person, and has some additional information.
schema Employee(Person):
    bankCard: int
    nationality: str

employee = Employee {
    firstName = &quot;Bob&quot;
    lastName = &quot;Green&quot;
    age = 18
    bankCard = 123456
    nationality = &quot;China&quot;
}
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">employee:
  firstName: Bob
  lastName: Green
  age: 18
  bankCard: 123456
  nationality: China
</code></pre>
<p>注意: KCL 只允许 schema 单继承</p>
<h2 id="b24-如何通过组合复用-schema-逻辑"><a class="header" href="#b24-如何通过组合复用-schema-逻辑">B.24. 如何通过组合复用 schema 逻辑？</a></h2>
<p>可以使用 KCL schema mixin 复用 schema 逻辑，mixin 一般被用于 schema 内部属性的分离数据，和数据映射等功能，可以使 KCL 代码更具模块化和声明性。注意不同的 mixin 之间的混入属性不建议定义依赖关系，会使得 mixin 使用方式复杂，一般一个 mixin 中作不超过三个属性混入即可。</p>
<pre><code class="language-python">schema Person:
    mixin [FullNameMixin, UpperMixin]

    firstName: str
    lastName: str
    fullName: str
    upper: str

schema FullNameMixin:
    fullName = &quot;{} {}&quot;.format(firstName, lastName)

schema UpperMixin:
    upper = fullName.upper()

person = Person {
    firstName = &quot;John&quot;
    lastName = &quot;Doe&quot;
}
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">person:
  firstName: John
  lastName: Doe
  fullName: John Doe
  upper: JOHN DOE
</code></pre>
<h2 id="b25-如何导入其他-kcl-文件"><a class="header" href="#b25-如何导入其他-kcl-文件">B.25. 如何导入其他 KCL 文件？</a></h2>
<p>通过 import 关键字可以导入其他 KCL 文件，KCL 配置文件被组织为模块。单个 KCL 文件被视为一个模块，目录被视为一个包，作为一个特殊的模块。import 关键字支持相对路径导入和绝对路径导入两种方式</p>
<p>比如对于如下目录结构:</p>
<pre><code>. 
└── root
    ├── kcl.mod
    ├── model
    │   ├── model1.k
    |   ├── model2.k
    │   └── main.k
    ├── service
    │   │── service1.k
    │   └── service2.k
    └── mixin
        └── mixin1.k
</code></pre>
<p>对于 <code>main.k</code>, 相对路径导入和绝对路径导入分别可以表示为:</p>
<pre><code class="language-python">import service  # 绝对路径导入, 根目录为kcl.mod所在的路径
import mixin  # 绝对路径导入, 根目录为kcl.mod所在的路径

import .model1  # 相对路径导入, 当前目录模块
import ..service  # 相对路径导入, 父目录
import ...root  # 相对路径导入, 父目录的父目录
</code></pre>
<p>注意，对于 KCL 的入口文件 <code>main.k</code>, 其不能导入自身所在的文件夹，否则会发生循环导入错误:</p>
<pre><code class="language-python">import model  # Error: recursively loading
</code></pre>
<h2 id="b26-什么情况下可以省略-import-"><a class="header" href="#b26-什么情况下可以省略-import-">B.26. 什么情况下可以省略 import ？</a></h2>
<p>除了 main 包当中的同一文件夹下的 KCL 可以相互引用而不需通过 import 相互引用，比如对于如下目录结构:</p>
<pre><code>. 
└── root
    ├── kcl.mod
    ├── model
    │   ├── model1.k
    |   ├── model2.k
    │   └── main.k
    ├── service
    │   │── service1.k
    │   └── service2.k
    └── mixin
        └── mixin1.k
</code></pre>
<p>当 main.k 作为 KCL 命令行入口文件时, model 文件夹中的 main.k, model1.k 和 model2.k 中的变量不能相互引用，需要通过 import 导入，但是 service 文件夹中的 service1.k 和 service2.k 当中的变量可以互相引用，忽略 import</p>
<p>service1.k</p>
<pre><code class="language-python">schema BaseService:
    name: str
    namespace: str
</code></pre>
<p>service2.k</p>
<pre><code class="language-python">schema Service(BaseService):
    id: str
</code></pre>
<h2 id="b27-有一行代码太长了如何在语法正确的情况下优雅地换行"><a class="header" href="#b27-有一行代码太长了如何在语法正确的情况下优雅地换行">B.27. 有一行代码太长了，如何在语法正确的情况下优雅地换行？</a></h2>
<p>在 KCL 中可以使用续行符 <code>\</code> 进行换行, 并且在字符串中也可以使用 <code>\</code> 表示续行</p>
<p>长字符串连接续行举例:</p>
<pre><code class="language-python">longString = &quot;Too long expression &quot; + \
             &quot;Too long expression &quot; + \
             &quot;Too long expression &quot;
</code></pre>
<p>推导表达式续行举例:</p>
<pre><code class="language-python">data = [1, 2, 3, 4]
dataNew = [
    d + 2 \
    for d in data \
    if d % 2 == 0
]
</code></pre>
<p>if 表达式续行举例:</p>
<pre><code class="language-python">condition = 1
data1 = 1 \
    if condition \
    else 2
data2 = 2 \
if condition \
else 1
</code></pre>
<p>三引号字符串内部续行举例:</p>
<pre><code class="language-python">longString = &quot;&quot;&quot;\
The first line\
The continue second line\
&quot;&quot;&quot;
</code></pre>
<p>注意: 使用续行符 <code>\</code> 的同时缩进的保持, 如下所示:</p>
<p>错误用例:</p>
<pre><code class="language-python">data1 = [
    1, 2,
    3, 4 \  
]  # Error, 需要保持右方括号]的缩进

data2 = [
    1, 2,
  3, 4 
]  # Error, 需要数字1和3的缩进统一
</code></pre>
<p>正确用例:</p>
<pre><code class="language-python">data1 = [
    1, 2,
    3, 4
]  # Right, 带缩进的列表定义

data2 = [ \
    1, 2, \
    3, 4  \
]  # Right, 使用续行符的列表定义, 实际效果是单行列表

data3 = [ \
    1, 2, \
  3, 4  \
]  # Right, 使用续行符的列表定义, 无需保持缩进, 实际效果是单行列表
</code></pre>
<h2 id="b28---这些符号是什么意思"><a class="header" href="#b28---这些符号是什么意思">B.28. **, * 这些符号是什么意思？</a></h2>
<ul>
<li><code>**</code>, <code>*</code> 出现在 dict/list 外部时分别表示乘方运算符和乘法运算符</li>
</ul>
<pre><code class="language-python">data1 = 2 ** 4  # 2的4次方等于16
data2 = 2 * 3  # 2乘以3等于6
</code></pre>
<ul>
<li><code>**</code>, <code>*</code> 出现在 dict/list 内部时表示解包运算符，经常用于 list/dict 的解包和合并, 与 Python 当中的解包运算符用法相同</li>
</ul>
<p>dict 的解包:</p>
<pre><code class="language-python">data = {&quot;key1&quot; = &quot;value1&quot;}
dataUnpack = {**data, &quot;key2&quot; = &quot;value2&quot;}  # 将data解包合并入dataUnpack中, {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}
</code></pre>
<p>list 的解包:</p>
<pre><code class="language-python">data = [1, 2, 3]
dataUnpack = [*data, 4, 5, 6]  # 将data解包合并入dataUnpack中, [1, 2, 3, 4, 5, 6]
</code></pre>
<h2 id="b29-如何取-listdictschema-的子元素"><a class="header" href="#b29-如何取-listdictschema-的子元素">B.29. 如何取 list/dict/schema 的子元素</a></h2>
<p>在 KCL 中可以使用 select 表达式或者 subscript 表达式取 list/dict/schema 的子元素</p>
<ul>
<li>对于 list 类型，可以使用 <code>[]</code> 取列表中的某一个元素或者某一些元素</li>
</ul>
<pre><code class="language-python">data = [1, 2, 3]  # 定义一个整数类型的数组
theFirstItem = data[0]  # 取数组中索引为0的元素，即第一个元素 1
theSecondItem = data[1]  # 取数组中索引为1的元素，即第一个元素 2
</code></pre>
<p>注意：索引的取值不能超出列表的长度，否则会发生错误，可以使用 <code>len</code> 函数获得数组的长度</p>
<pre><code class="language-python">data = [1, 2, 3]
dataLength = len(data)  # 数组长度为3
item = data[3]  # 发生数组索引越界错误
</code></pre>
<p>此外，还可以使用负数索引倒序获得列表中的元素</p>
<pre><code class="language-python">data = [1, 2, 3]
item1 = data[-1]  # 取数组中索引为-1的元素，即最后一个元素 3
item2 = data[-2]  # 取数组中索引为-2的元素，即倒数第二个元素 2
</code></pre>
<p>综上，列表索引的取值范围为 <code>[-len, len - 1]</code></p>
<p>当想要取得列表的一部分时，可以在 <code>[]</code> 中使用切片表达式，其具体语法为 <code>[&lt;列表开始索引&gt;:&lt;列表终止索引&gt;:&lt;列表遍历步长&gt;]</code>，注意索引开始终止的取值区间为 <code>左闭右开[&lt;列表开始索引&gt;, &lt;列表终止索引&gt;)</code>，注意三个参数均可省略不写</p>
<pre><code class="language-python">data = [1, 2, 3, 4, 5]
dataSlice0 = data[1:2]  # 取列表中索引开始为 1, 终止索引为 2 的元素集合 [2]
dataSlice1 = data[1:3]  # 取列表中索引开始为 1, 终止索引为 3 的元素集合 [2, 3]
dataSlice2 = data[1:]   # 取列表中索引开始为 1, 终止索引为 最后一个索引 的元素集合 [2, 3, 4, 5]
dataSlice3 = data[:3]   # 取列表中索引开始为 第一个索引, 终止索引为 3 的元素集合 [1, 2, 3]
dataSlice4 = data[::2]  # 取列表中索引开始为 第一个索引, 终止索引为 最后一个索引 的元素集合(步长为2) [1, 3, 5]
dataSlice5 = data[::-1] # 反转一个列表，[5, 4, 3, 2, 1]
dataSlice6 = data[2:1]  # 当开始，终止，步长三个参数组合不满足条件时返回空列表 []

</code></pre>
<ul>
<li>对于 dict/schema 类型，可以使用 <code>[]</code> 和 <code>.</code> 两种方式取 dict/schema 中的子元素</li>
</ul>
<pre><code class="language-python">data = {key1: &quot;value1&quot;, key2: &quot;value2&quot;}
data1 = data[&quot;key1&quot;]  # &quot;value1&quot;
data2 = data.key1  # &quot;value1&quot;
data3 = data[&quot;key2&quot;]  # &quot;value2&quot;
data4 = data.key2  # &quot;value2&quot;
</code></pre>
<pre><code class="language-python">schema Person:
    name: str = &quot;Alice&quot;
    age: int = 18

person = Person {}
name1 = person.name  # &quot;Alice&quot;
name2 = person[&quot;name&quot;]  # &quot;Alice&quot;
age1 = person.age  # 18
age2 = person.age  # 18
</code></pre>
<p>当键值在 dict 中不存在时，返回未定义值 <code>Undefined</code></p>
<pre><code class="language-python">data = {key1 = &quot;value1&quot;, key2 = &quot;value2&quot;}
data1 = data[&quot;not_exist_key&quot;]  # Undefined
data2 = data.not_exist_key  # Undefined
</code></pre>
<p>可以使用 <code>in</code> 关键字判断某个键值是否在 dict/schema 中存在</p>
<pre><code class="language-python">data = {key1 = &quot;value1&quot;, key2 = &quot;value2&quot;}
exist1 = &quot;key1&quot; in data  # True
exist2 = &quot;not_exist_key&quot; in data  # False
</code></pre>
<p>当键值中存在 <code>.</code> 时或者需要运行时取一个键值变量对应的值时，只能使用 <code>[]</code> 方式，如无特殊情况，使用 <code>.</code> 即可:</p>
<pre><code class="language-python">name = &quot;key1&quot;
data = {key1 = &quot;value1&quot;, key2 = &quot;value2&quot;, &quot;contains.dot&quot; = &quot;value3&quot;}
data1 = data[name]  # &quot;value1&quot;
data2 = data[&quot;contains.dot&quot;]  # &quot;value3&quot;
# 注意这样子是不对的 data3 = data.contains.dot
</code></pre>
<p>注意：上述取子元素的运算符不能对非 list/dict/schema 集合类型的值进行操作，比如整数，空值等。</p>
<pre><code class="language-python">data = 1
data1 = 1[0] # error
</code></pre>
<pre><code class="language-python">data = None
data1 = None[0] # error
</code></pre>
<p>因此，在取集合类型的子元素时往往要进行非空或者长度判断：</p>
<pre><code class="language-python">data = []
item = data[0] if data else None
</code></pre>
<p>可以使用非空判断符 <code>?</code> 添加在 <code>[]</code>, <code>.</code> 的前面表示进行 if 非空判断，当不满足条件时返回 None，比如上述代码可以简化为:</p>
<pre><code class="language-python">data = []
item1 = data?[0]  # 当data为空时，返回空值 None
item2 = data?[0] or 1  # 当data为空时，返回空值 None, 如果不想返回 None, 还可与 or 运算符连用返回其他默认值
</code></pre>
<p>使用 <code>?</code> 可以进行递归调用, 避免复杂繁琐的非空判断</p>
<pre><code class="language-python">data = {key1.key2.key3 = []}
item = data?.key1?.key2?.key3?[0]
</code></pre>
<h2 id="b30-如何在-kcl-代码中判断变量的类型"><a class="header" href="#b30-如何在-kcl-代码中判断变量的类型">B.30. 如何在 KCL 代码中判断变量的类型</a></h2>
<p>KCL typeof built-in 函数可以在该函数执行时立即返回一个变量的类型(字符串表示)用于类型断言</p>
<p>用法举例:</p>
<pre><code class="language-python">import sub as pkg

_a = 1

t1 = typeof(_a)
t2 = typeof(&quot;abc&quot;)

schema Person:
    name?: any

_x1 = Person{}
t3 = typeof(_x1)

_x2 = pkg.Person{}
t4 = typeof(_x2)
t5 = typeof(_x2, full_name=True)

t6 = typeof(_x1, full_name=True)

# 输出
# t1: int
# t2: str
# t3: Person
# t4: Person
# t5: sub.Person
# t6: __main__.Person
</code></pre>
<h2 id="b31-关键字和-kcl-变量名冲突了可以怎么解决"><a class="header" href="#b31-关键字和-kcl-变量名冲突了可以怎么解决">B.31. 关键字和 KCL 变量名冲突了可以怎么解决?</a></h2>
<p>对于与关键字冲突的标识符，可以在标识符前添加 <code>$</code> 前缀用于定义一个关键字标识符，比如如下代码中使用了 <code>if</code>, <code>else</code> 等关键字作为标识符并且可以得到相应的 YAML 输出</p>
<pre><code class="language-python">$if = 1
$else = &quot;s&quot;

schema Data:
    $filter: str = &quot;filter&quot;

data = Data {}
</code></pre>
<p>输出 YAML：</p>
<pre><code class="language-yaml">data:
  filter: filter
if: 1
else: s
</code></pre>
<p>注意：在非关键字标识符前添加 <code>$</code> 前缀的效果与不添加相同</p>
<pre><code class="language-python">_a = 1
$_a = 2  # 等效于 `_a = 2`
</code></pre>
<h2 id="b32-kcl-的内置类型是-kcl-的关键字吗是否可用于变量的定义"><a class="header" href="#b32-kcl-的内置类型是-kcl-的关键字吗是否可用于变量的定义">B.32. KCL 的内置类型是 KCL 的关键字吗？是否可用于变量的定义</a></h2>
<p>KCL 的内置类型包括 <code>int</code>, <code>float</code>, <code>bool</code> 和 <code>str</code> 四种类型，它们不是 KCL 的关键字，可用于变量的定义，比如如下代码：</p>
<pre><code class="language-py">int = 1
str = 2
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">int: 1
str: 2
</code></pre>
<p>注意：如无特殊需求，不建议变量的名称取这些内置类型，因为在有些语言当中，它们作为关键字存在</p>
<h2 id="b33-如何在-kcl-中实现类似-enum-枚举的功能"><a class="header" href="#b33-如何在-kcl-中实现类似-enum-枚举的功能">B.33. 如何在 KCL 中实现类似 Enum 枚举的功能</a></h2>
<p>有两种方式可以在 KCL 中实现 Enum 枚举的方式</p>
<ul>
<li>(推荐)使用<strong>字面值类型</strong>的<strong>联合类型</strong></li>
</ul>
<pre><code class="language-python">schema Person:
    name: str
    gender: &quot;Male&quot; | &quot;Female&quot;

person = Person {
    name = &quot;Alice&quot;
    gender = &quot;Male&quot;  # gender 只能为 &quot;Male&quot; 或者 &quot;Female&quot; 
}
</code></pre>
<p>一个复杂例子</p>
<pre><code class="language-python">schema Config:
    colors: [&quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;]  # colors 是一个枚举数组

config = Config {
    colors = [
        &quot;Red&quot;
        &quot;Blue&quot;
    ]
}
</code></pre>
<ul>
<li>使用 schema 的 check 表达式</li>
</ul>
<pre><code class="language-python">schema Person:
    name: str
    gender: &quot;Male&quot; | &quot;Female&quot;

    check:
        gender in [&quot;Male&quot;, &quot;Female&quot;]

person = Person {
    name = &quot;Alice&quot;
    gender = &quot;Male&quot;  # gender 只能为 &quot;Male&quot; 或者 &quot;Female&quot; 
}
</code></pre>
<h2 id="b34-如何求字典-dict-的长度"><a class="header" href="#b34-如何求字典-dict-的长度">B.34. 如何求字典 dict 的长度</a></h2>
<p>在 KCL 中可以使用 <code>len</code> 内置函数直接求 dict 的长度</p>
<pre><code class="language-python">len1 = len({k1: &quot;v1&quot;})  # 1
len2 = len({k1: &quot;v1&quot;, k2: &quot;v2&quot;})  # 2
varDict = {k1 = 1, k2 = 2, k3 = 3}
len3 = len(varDict)  # 3
</code></pre>
<p>此外，使用 <code>len</code> 函数还可以求 <code>str</code> 和 <code>list</code> 类型长度</p>
<pre><code class="language-python">len1 = len(&quot;hello&quot;)  # 5
len2 = len([1, 2, 3])  # 3
</code></pre>
<h2 id="b35-如何在-kcl-中编写带条件的配置"><a class="header" href="#b35-如何在-kcl-中编写带条件的配置">B.35. 如何在 KCL 中编写带条件的配置</a></h2>
<p>在 KCL 中，除了支持在顶级的语句中书写 <code>if-elif-else</code> 条件表达式以外，还支持在 KCL 复杂结构（list/dict/schema）中书写条件表达式，支持带条件的配置书写。</p>
<pre><code class="language-python">x = 1
# List 结构中的 if 条件语句
dataList = [
    if x == 1:
]
# Dict 结构中的 if 条件语句
dataDict = {
    if x == 1: key1 = &quot;value1&quot;  # 可以同一行书写
    elif x == 2:
        key2 = &quot;value2&quot;  # 可以跨行书写
}
# Schema 结构中的 if 条件语句
schema Config:
    id?: int
env = &quot;prod&quot;
dataSchema = Config {
    if env == &quot;prod&quot;:
        id = 1
    elif env == &quot;pre&quot;:
        id = 2
    elif env == &quot;test&quot;:
        id = 3
}
</code></pre>
<p>注意：为降低书写配置复杂性提升可读性，在 KCL 复杂结构中暂不支持 <code>if-elif-else</code> 条件的嵌套</p>
<h2 id="b36-kcl-中的--运算符会作深度比较嘛"><a class="header" href="#b36-kcl-中的--运算符会作深度比较嘛">B.36. KCL 中的 == 运算符会作深度比较嘛？</a></h2>
<p>KCL 中的 <code>==</code> 运算符</p>
<ul>
<li>对于基本类型 <code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code> 的变量是直接比较它们的值是否相等</li>
<li>对于复合类型 <code>list</code>, <code>dict</code>, <code>schema</code> 的变量会深度递归地比较其中的子元素是否相等
<ul>
<li><code>list</code> 类型深度递归递归比较每个索引的值以及长度</li>
<li><code>dict</code>/<code>schema</code> 类型深度递归比较每个属性的值(与属性出现的顺序无关)</li>
</ul>
</li>
</ul>
<pre><code class="language-python">print([1, 2] == [1, 2])  # True
print([[0, 1], 1] == [[0, 1], 1])  # True
print({k1 = 1, k2 = 2} == {k2 = 2, k1 = 1})  # True

print([1, 2] == [1, 2, 3])  # False
print({k1 = 1, k2 = 2, k3 = 3} == {k2 = 2, k1 = 1})  # False
</code></pre>
<h2 id="b37-如何对-kcl-中已有的配置块进行修改"><a class="header" href="#b37-如何对-kcl-中已有的配置块进行修改">B.37. 如何对 KCL 中已有的配置块进行修改</a></h2>
<p>在 KCL 中，存在三种<strong>属性运算符</strong> <code>=</code>、<code>+=</code>、<code>:</code>，可以用来对已有配置块进行修改，并且可以使用<strong>解包运算符</strong> <code>**</code> 等&quot;继承&quot;一个配置块的所有属性字段和值。</p>
<ul>
<li><code>=</code> 属性运算符表示覆盖，使用 <code>=</code> 运算符可以对属性进行有优先级的覆盖/删除，(如果是用 <code>Undefined</code> 覆盖则表示删除)</li>
<li><code>+=</code> 属性运算符表示添加，一般用于对 list 类型的属性添加子元素，<code>+=</code> 属性运算符后跟的操作数类型也只能为 list 类型</li>
<li><code>:</code> 属性运算符表示幂等合并，当值发生冲突时进行报错，不冲突时进行合并</li>
</ul>
<h3 id="b覆盖属性运算符"><a class="header" href="#b覆盖属性运算符">B.覆盖属性运算符=</a></h3>
<p>最常使用的属性运算符是 <code>=</code>，表示一个属性的赋值，多次对同一个属性进行使用时表示覆盖，对于 <code>{}</code> 外的全局变量或者 <code>{}</code> 内的属性均表示使用值覆盖这个全局变量或者属性</p>
<pre><code class="language-python">data = {  # 定义一个字典类型的变量 data
    a = 1  # 使用 = 在 data 中声明一个值为 1 的属性 a
    b = 2  # 使用 = 在 data 中声明一个值为 1 的属性 b
}  # 最终 data 的值为 {&quot;a&quot;: 1, &quot;b&quot;: 1}
</code></pre>
<p>在 schema 实例化处也可以使用覆盖属性运算符实现对 schema 默认值的覆盖效果，一般在创建新的 schema 实例时如无特殊的需求，一般使用 <code>=</code> 即可</p>
<pre><code class="language-python">schema Person:
    name: str = &quot;Alice&quot;  # schema Person 的 name 属性具有默认值 &quot;Alice&quot;
    age: int = 18  # schema Person 的 age 属性具有默认值 18 
        
bob = Person {
    name = &quot;Bob&quot;  # &quot;Bob&quot; -&gt; &quot;Alice&quot;, 属性 name 的值 &quot;Bob&quot; 的值会覆盖 schema Person name 属性的默认值 &quot;Alice&quot;
    age = 10  # 10 -&gt; 18, 属性 age 的值 10 的值会覆盖 schema Person age 属性的默认值 18
}  # 最终 bob 的值为 {&quot;name&quot;: &quot;Bob&quot;, age: 10}
</code></pre>
<h3 id="b插入属性运算符-"><a class="header" href="#b插入属性运算符-">B.插入属性运算符 +=</a></h3>
<p>插入属性运算符表示对一个属性的值进行原地添加，比如向一个 list 类型的属性添加新的元素</p>
<pre><code class="language-python">data = {
    args = [&quot;kcl&quot;]  # 使用 = 在 data 中声明一个值为 [&quot;kcl&quot;] 的属性 args
    args += [&quot;-Y&quot;, &quot;settings.yaml&quot;]  # 使用 += 运算符向属性 args 中添加两个元素&quot;-Y&quot;, &quot;settings.yaml&quot;
}  # 最终 data 的值为 {&quot;args&quot;: [&quot;kcl&quot;, &quot;-Y&quot;, &quot;settings.yaml&quot;]}
</code></pre>
<h3 id="b合并属性运算符"><a class="header" href="#b合并属性运算符">B.合并属性运算符:</a></h3>
<p>合并属性运算符表示对一个属性的不同配置块值进行幂等的合并，当需要合并的值发生冲突时进行报错，多用于复杂配置合并场景</p>
<pre><code class="language-python">data = {
    labels: {key1: &quot;value1&quot;}  # 定义一个 labels, 它的类型为 dict, 值为 {&quot;key1&quot;: &quot;value1&quot;}
    labels: {key2: &quot;value2&quot;}  # 使用 : 将 labels 不同的配置值进行合并
}  # 最终 data 的值为 {&quot;labels&quot;: {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}}
</code></pre>
<p>合并属性运算符属于幂等运算符，需要合并的配置块的书写顺序不影响其最终结果，比如上述例子中的两个 <code>labels</code> 属性也可以调换顺序书写</p>
<pre><code class="language-python">data = {  # 同一个属性 labels 的合并书写顺序不影响最终结果
    labels: {key2: &quot;value2&quot;}  # 定义一个 labels, 它的类型为 dict, 值为 {&quot;key2&quot;: &quot;value2&quot;}
    labels: {key1: &quot;value1&quot;}  # 使用 : 将 labels 不同的配置值进行合并
}  # 最终 data 的值为 {&quot;labels&quot;: {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}}
</code></pre>
<p>注意：合并属性运算符会对合并的值进行冲突检查，当需要合并的配置值发生冲突时进行报错</p>
<pre><code class="language-python">data = {
    a: 1  # a 的值为 1
    a: 2  # Error: a 的值 2 不能与 a 的值 1 进行合并，因为其结果存在冲突，且合并是不可交换的
}
</code></pre>
<pre><code class="language-python">data = {
    labels: {key: &quot;value&quot;}
    labels: {key: &quot;override_value&quot;}  # Error: 两个 labels 的 key 属性的值 &quot;value&quot; 和 &quot;override_value&quot; 是冲突的，不可合并
}
</code></pre>
<p>合并运算符对不同类型的使用方式不同</p>
<ul>
<li>不同类型的属性不能进行合并</li>
<li>当属性为 int/float/str/bool 等基本类型时，运算符会判断需要合并的值是否相等，不相等时发生合并冲突错误</li>
</ul>
<pre><code class="language-python">data = {
    a: 1
    a: 1  # Ok
    a: 2  # Error
}
</code></pre>
<ul>
<li>当属性为 list 类型时
<ul>
<li>当需要合并的两个 list 长度不相等时，发生合并冲突错误</li>
<li>当需要合并的两个 list 长度相等时，按照索引递归地合并 list 当中的每一个元素</li>
</ul>
</li>
</ul>
<pre><code class="language-python">data = {
    args: [&quot;kcl&quot;]
    args: [&quot;-Y&quot;, &quot;settings.yaml&quot;]  # Error: 两个 args 属性的长度不相同，不能进行合并
    env: [{key1: &quot;value1&quot;}]
    env: [{key2: &quot;value2&quot;}]  # Ok: 最终 env 属性的值为 [{&quot;key1&quot;: &quot;value1&quot;}, {&quot;key2&quot;: &quot;value2&quot;}]
}
</code></pre>
<ul>
<li>当属性为 dict/schema 类型时，按照 key 递归地合并 dict/schema 当中的每一个元素</li>
</ul>
<pre><code class="language-python">data = {
    labels: {key1: &quot;value1&quot;}
    labels: {key2: &quot;value2&quot;}
    labels: {key3: &quot;value3&quot;}
}  # 最终 data 的值为 {&quot;labels&quot;: {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;value3&quot;}}
</code></pre>
<ul>
<li>任意类型的属性与 None/Undefined 合并的结果都是其自身</li>
</ul>
<pre><code class="language-python">data = {
    args: [&quot;kcl&quot;]
    args: None  # Ok
    args: Undefined  #Ok
}  # 最终 data 的值为 {&quot;args&quot;: [&quot;kcl&quot;]}
</code></pre>
<p>支持顶级变量使用 <code>:</code> 属性声明与合并(仍然可使用 <code>config = Config {}</code> 的方式声明一个配置块)</p>
<pre><code class="language-python">schema Config:
    id: int
    value: str

config: Config {
    id: 1
}
config: Config {
    value: &quot;1&quot;
}
&quot;&quot;&quot;
此处定义了两个 Config 配置块，使用 : 运算符将可以两个配置块合并在一起，其合并的等效代码如下:
config: Config {
    id: 1
    value: &quot;1&quot;
}
&quot;&quot;&quot;
</code></pre>
<p>综上所述，合并属性运算符 <code>:</code> 的使用场景主要为复杂数据结构 list/dict/schema 的合并操作，一般情况如无特殊需求使用 <code>=</code> 和 <code>+=</code> 两种属性运算符即可，因此属性运算符的最佳实践如下</p>
<ul>
<li>对于基本类型，采用 <code>=</code> 运算符</li>
<li>对于 list 类型，一般采用 <code>=</code> 和 <code>+=</code> 运算符，使用 <code>=</code> 表示完全覆盖 list 属性，使用 <code>+=</code> 表示向 list 中添加元素</li>
<li>对于 dict/schema 类型，一般采用 <code>:</code> 运算符</li>
</ul>
<p>此外，当已经存在一个配置时，可以使用解包运算符 <code>**</code> 获得此配置的所有字段值并对其中的字段使用不同属性运算符进行修改，并获得一个新的配置</p>
<pre><code class="language-python">configBase = {
    intKey = 1  # 一个 int 类型的属性
    floatKey = 1.0  # 一个 float 类型的属性
    listKey = [0]  # 一个 list 类型的属性
    dictKey = {key1: &quot;value1&quot;}  # 一个 dict 类型的属性
}
configNew = {
    **configBase  # 将 configBase 解包内联到 configNew 中
    intKey = 0  # 使用 覆盖属性运算符 = 将 intKey 属性覆盖为 1
    floatKey = Undefined  # 使用 覆盖属性运算符 = 删除 floatKey 属性
    listKey += [1]  # 使用 添加属性运算符 += 为 listKey 属性尾部添加一个属性 1
    dictKey: {key2: &quot;value2&quot;}  # 使用 合并属性运算符 : 为 dictKey 属性扩展一个键-值对
}
</code></pre>
<p>输出的 YAML 结果为:</p>
<pre><code class="language-yaml">configBase:
  intKey: 1
  floatKey: 1.0
  listKey:
  - 0
  dictKey:
    key1: value1
configNew:
  intKey: 0
  listKey:
  - 0
  - 1
  dictKey:
    key1: value1
    key2: value2
</code></pre>
<p>或者可以使用 <code>|</code> 运算符对两个配置块合并:</p>
<pre><code class="language-python">configBase = {
    intKey = 1  # 一个 int 类型的属性
    floatKey = 1.0  # 一个 float 类型的属性
    listKey = [0]  # 一个 list 类型的属性
    dictKey = {key1: &quot;value1&quot;}  # 一个 dict 类型的属性
}
configNew = configBase | { # 使用 | 进行合并
    intKey = 0  # 使用 覆盖属性运算符 = 将 intKey 属性覆盖为 1
    floatKey = Undefined  # 使用 覆盖属性运算符 = 删除 floatKey 属性
    listKey += [1]  # 使用 添加属性运算符 += 为 listKey 属性尾部添加一个属性 1
    dictKey: {key2: &quot;value2&quot;}  # 使用 合并属性运算符 : 为 dictKey 属性扩展一个键-值对
}
</code></pre>
<p>输出的 YAML 结果为:</p>
<pre><code class="language-yaml">configBase:
  intKey: 1
  floatKey: 1.0
  listKey:
  - 0
  dictKey:
    key1: value1
configNew:
  intKey: 0
  listKey:
  - 0
  - 1
  dictKey:
    key1: value1
    key2: value2
</code></pre>
<h3 id="bkcl-发生-conflicting-values-on-the-attribute-attr-between-value1-and-value2-错误的解决方式"><a class="header" href="#bkcl-发生-conflicting-values-on-the-attribute-attr-between-value1-and-value2-错误的解决方式">B.KCL 发生 conflicting values on the attribute 'attr' between {value1} and {value2} 错误的解决方式</a></h3>
<p>当 KCL 发生类似 conflicting values on the attribute 'attr' between {value1} and {value2} 错误时，一般是合并属性运算符 <code>:</code> 的使用问题，表明 <code>value1</code> 和 <code>value2</code> 配置进行合并时在属性 <code>attr</code> 处发生了冲突错误。一般情况将 value2 的 attr 属性修改为其他属性运算符即可，使用 <code>=</code> 表示覆盖，使用 <code>+=</code> 表示添加</p>
<p>比如对于如下代码:</p>
<pre><code class="language-python">data = {k: 1} | {k: 2}  # Error: conflicting values on the attribute 'k' between {'k': 1} and {'k': 2}
</code></pre>
<p>则可以使用 <code>=</code> 属性运算符修改为如下形式</p>
<pre><code class="language-python">data = {k: 1} | {k = 2}  # Ok: the value 2 will override the value 1 through the `=` operator
</code></pre>
<h2 id="b38-kcl-中如何同时遍历多个元素"><a class="header" href="#b38-kcl-中如何同时遍历多个元素">B.38. KCL 中如何同时遍历多个元素</a></h2>
<p>KCL 中可以使用 for 推导表达式遍历多个元素</p>
<ul>
<li>举例 1: 使用 for 进行 2 维元素遍历</li>
</ul>
<pre><code class="language-python">dimension1 = [1, 2, 3]  # dimension1 列表的长度是 3
dimension2 = [1, 2, 3]  # dimension2 列表的长度是 3
matrix = [x + y for x in dimension1 for y in dimension2]  # matrix 列表的长度是 9 = 3 * 3
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-yaml">dimension1:
- 1
- 2
- 3
dimension2:
- 1
- 2
- 3
matrix:
- 2
- 3
- 4
- 3
- 4
- 5
- 4
- 5
- 6
</code></pre>
<ul>
<li>举例 2: 使用 for 循环配合 zip 内置函数按照索引一一对应对多个列表进行遍历</li>
</ul>
<pre><code class="language-python">dimension1 = [1, 2, 3]  # dimension1 列表的长度是 3
dimension2 = [1, 2, 3]  # dimension2 列表的长度是 3
dimension3 = [d[0] + d[1] for d in zip(dimension1, dimension2)]  # dimension3 列表的长度是 3
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-yaml">dimension1:
- 1
- 2
- 3
dimension2:
- 1
- 2
- 3
dimension3:
- 2
- 4
- 6
</code></pre>
<h2 id="b39-kcl-中如何为-option-函数设定默认值"><a class="header" href="#b39-kcl-中如何为-option-函数设定默认值">B.39. KCL 中如何为 option 函数设定默认值</a></h2>
<p>在 KCL 中，当 option 属性的值为 None/Undefined 空时，可以使用逻辑或 <code>or</code> 直接指定一个默认值</p>
<pre><code class="language-python">value = option(&quot;key&quot;) or &quot;default_value&quot;  # 当 key 的值存在时，取 option(&quot;key&quot;) 的值，否则取 &quot;default_value&quot;
</code></pre>
<p>或者使用 option 函数的 default 参数</p>
<pre><code class="language-python">value = option(&quot;key&quot;, default=&quot;default_value&quot;)  # 当 key 的值存在时，取 option(&quot;key&quot;) 的值，否则取 &quot;default_value&quot;
</code></pre>
<h2 id="b40-kcl-中-schema-怎么检查多个属性不能同时为空"><a class="header" href="#b40-kcl-中-schema-怎么检查多个属性不能同时为空">B.40. KCL 中 schema 怎么检查多个属性不能同时为空</a></h2>
<p>在 KCL 中，对于 schema 的单个属性不能为空可以使用属性非空标记</p>
<pre><code class="language-python">schema Person:
    name: str  # required. name 不能为空
    age: int  # required. age 不能为空
    id?: int  # optional. id 可以留空
</code></pre>
<p>而对于需要检查 schema 属性不能同时为空或者只能有一者为空的情况时，需要借助 schema check 表达式进行书写，下面以同一个 schema Config 的两个属性 a, b 为例进行说明</p>
<ul>
<li>Config 的 a, b 属性不能同时为空</li>
</ul>
<pre><code class="language-python">schema Config:
    a?: str
    b?: str

    check:
        a or b, &quot;a属性和b属性不能同时为空&quot;
</code></pre>
<ul>
<li>Config 的 a, b 属性只能有一个为空或者都为空（不能同时存在或不为空）</li>
</ul>
<pre><code class="language-python">schema Config:
    a?: str
    b?: str

    check:
        a or b, &quot;a属性和b属性不能同时填写&quot;
</code></pre>
<h2 id="b41-kcl-中-import-了某个文件但是找不到其同目录下其他-kcl-文件定义的-schema-可能是什么原因"><a class="header" href="#b41-kcl-中-import-了某个文件但是找不到其同目录下其他-kcl-文件定义的-schema-可能是什么原因">B.41. KCL 中 import 了某个文件但是找不到其同目录下其他 KCL 文件定义的 schema 可能是什么原因</a></h2>
<p>可能是与使用 import 仅导入了这个文件夹的这一个文件导致，在 KCL 中，import 支持导入整个文件夹，也支持导入某一个文件夹下的的某一个 KCL 文件，比如对于如下目录结构</p>
<pre><code>.
├── kcl.mod
├── main.k
└── pkg
    ├── pkg1.k
    ├── pkg2.k
    └── pkg3.k
</code></pre>
<p>在根目录下存在入口文件 main.k，可以在 main.k 中书写如下代码导入整个 pkg 文件夹，此时 pkg 文件夹下的所有 schema 定义互相可见</p>
<pre><code class="language-python">import pkg
</code></pre>
<p>还可以书写如下代码导入单个文件 pkg/pkg1.k，此时 pkg1.k 不能找到其他文件即 pkg2.k/pkg3.k 下的 schema 定义</p>
<pre><code class="language-python">import pkg.pkg1
</code></pre>
<h2 id="b42-kcl-中的缩进是如何处理的"><a class="header" href="#b42-kcl-中的缩进是如何处理的">B.42. KCL 中的缩进是如何处理的?</a></h2>
<p>在 KCL 中，在出现冒号 <code>:</code>、中括号对 <code>[]</code> 以及大括号对 <code>{}</code> 时，一般需要使用换行 + 缩进，同一缩进级的缩进空格数需要保持一致，一个缩进级一般采用 4 个空格表示</p>
<ul>
<li>冒号 <code>:</code> 后跟换行 + 缩进</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;if 语句中的缩进&quot;&quot;&quot;
_a = 1
_b = 1
if _a &gt;= 1:  # 冒号后跟换行+缩进
    if _a &gt; 8:
        _b = 2
    elif a &gt; 6:
        _b = 3

&quot;&quot;&quot;schema 定义中的缩进&quot;&quot;&quot;
schema Person:  # 冒号后跟换行+缩进
    name: str
    age: int
</code></pre>
<ul>
<li>中括号对 <code>[]</code> 后跟换行 + 缩进</li>
</ul>
<pre><code class="language-python">data = [  # 左中括号 [ 后跟换行+缩进
    1
    2
    3
]  # 右中括号 ] 前取消缩进
</code></pre>
<pre><code class="language-python">data = [  # 左中括号 [ 后跟换行+缩进
    i * 2 for i in range(5)
]  # 右中括号 ] 前取消缩进
</code></pre>
<ul>
<li>大括号对 <code>{}</code> 后跟换行 + 缩进</li>
</ul>
<pre><code class="language-python">data = {  # 左大括号 { 后跟换行+缩进
    k1 = &quot;v1&quot;
    k2 = &quot;v2&quot;
}  # 右大括号 } 前取消缩进
</code></pre>
<pre><code class="language-python">data = {  # 左大括号 { 后跟换行+缩进
    str(i): i * 2 for i in range(5)
}  # 右大括号 } 前取消缩进
</code></pre>
<h2 id="b43-如何为-kcl-代码编写简单的测试"><a class="header" href="#b43-如何为-kcl-代码编写简单的测试">B.43. 如何为 KCL 代码编写简单的测试？</a></h2>
<p>KCL 目前的版本还不支持内部程序调试，可以使用 assert 语句以及 print 函数实现数据的断言和打印查看</p>
<pre><code class="language-python">a = 1
print(&quot;The value of a is&quot;, a)
assert a == 1
</code></pre>
<p>此外，还可以借助 kcl-test 测试工具编写 KCL 内部编写测试用例</p>
<p>假设有 hello.k 文件，代码如下:</p>
<pre><code class="language-python">schema Person:
    name: str = &quot;kcl&quot;
    age: int = 1

hello = Person {
    name = &quot;hello kcl&quot;
    age = 102
}
</code></pre>
<p>构造 hello_test.k 测试文件，内容如下：</p>
<pre><code class="language-python">schema TestPerson:
    a = Person{}
    assert a.name == 'kcl'

schema TestPerson_age:
    a = Person{}
    assert a.age == 1

schema TestPerson_ok:
    a = Person{}
    assert a.name == &quot;kcl&quot;
    assert a.age == 1
</code></pre>
<p>然后再目录下执行 kcl-test 命令:</p>
<pre><code>$ kcl-test
ok   /pkg/to/app [365.154142ms]
$
</code></pre>
<h2 id="b44-kcl-中如何定义函数或定义方法"><a class="header" href="#b44-kcl-中如何定义函数或定义方法">B.44. KCL 中如何定义函数或定义方法？</a></h2>
<p>schema 结构在一定程度上充当了函数的功能，并且这个函数具有多个输入参数和多个输出参数的能力，比如如下代码可以实现一个斐波那契数列的功能:</p>
<pre><code class="language-python">schema Fib:
    n: int
    value: int = 1 if n &lt;= 2 else (Fib {n: n - 1}).value + (Fib {n: n - 2}).value

fib8 = (Fib {n: 8}).value
</code></pre>
<p>输出结果为:</p>
<pre><code class="language-yaml">fib8: 21
</code></pre>
<p>一个合并列表为字典的 schema 函数</p>
<pre><code class="language-python">schema UnionAll[data, n]:
    _?: [] = data
    value?: {:} = ((UnionAll(data=data, n=n - 1) {}).value | data[n] if n &gt; 0 else data[0]) if data else {}

schema MergeList[data]:
    &quot;&quot;&quot;Union一个列表中的所有元素返回合并字典

    [{&quot;key1&quot;: &quot;value1&quot;}, {&quot;key2&quot;: &quot;value2&quot;}, {&quot;key3&quot;: &quot;value3&quot;}] -&gt; {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;value3&quot;}
    &quot;&quot;&quot;
    _?: [] = data
    value?: {:} = (UnionAll(data=data, n=len(data) - 1) {}).value if data else {}
</code></pre>
<p>此外，KCL 支持使用 <code>lambda</code> 关键字定义一个函数:</p>
<pre><code class="language-python">func = lambda x: int, y: int -&gt; int {
    x + y
}
a = func(1, 1)  # 2
</code></pre>
<p>lambda 函数具有如下特性：</p>
<ul>
<li>lambda 函数将最后一个表达式的值作为函数的返回值，空函数体返回 None。</li>
<li>返回值类型注解可以省略，返回值类型为最后一个表达式值的类型</li>
<li>函数体中没有与顺序无关的特性，所有的表达式都是按顺序执行的</li>
</ul>
<pre><code class="language-python">_func = lambda x: int, y: int -&gt; int {
    x + y
}  # Define a function using the lambda expression
_func = lambda x: int, y: int -&gt; int {
    x - y
}  # Ok
_func = lambda x: int, y: int -&gt; str {
    str(x + y)
}  # Error (int, int) -&gt; str can't be assigned to (int, int) -&gt; int
</code></pre>
<p>lambda 函数对象不能参与任何计算，只能在赋值语句和调用语句中使用。</p>
<pre><code class="language-python">func = lambda x: int, y: int -&gt; int {
    x + y
}
x = func + 1  # Error: unsupported operand type(s) for +: 'function' and 'int(1)'
</code></pre>
<pre><code class="language-python">a = 1
func = lambda x: int {
    x + a
}
funcOther = lambda f, para: int {
    f(para)
}
r = funcOther(func, 1)  # 2
</code></pre>
<p>输出为：</p>
<pre><code class="language-python">a: 1
r: 2
</code></pre>
<p>可以定义一个匿名函数并直接调用</p>
<pre><code class="language-python">result = (lambda x, y {
    z = 2 * x
    z + y
})(1, 1)  # 3
</code></pre>
<p>可以在 for 循环使用使用匿名函数</p>
<pre><code class="language-python">result = [(lambda x, y {
    x + y
})(x, y) for x in [1, 2] for y in [1, 2]]  # [2, 3, 3, 4]
</code></pre>
<p>可以在 KCL schema 中定义并使用函数</p>
<pre><code class="language-python">_funcOutOfSchema = lambda x: int, y: int {
    x + y
}
schema Data:
    _funcInSchema = lambda x: int, y: int {
        x + y
    }
    id0: int = _funcOutOfSchema(1, 1)
    id1: int = _funcInSchema(1, 1)
    id2: int = (lambda x: int, y: int {
        x + y
    })(1, 1)
</code></pre>
<p>输出 YAML 为:</p>
<pre><code class="language-yaml">data:
  id0: 2
  id1: 2
  id2: 2
</code></pre>
<h2 id="b45-为什么变量赋值为枚举类型字面值联合类型时会报错"><a class="header" href="#b45-为什么变量赋值为枚举类型字面值联合类型时会报错">B.45. 为什么变量赋值为枚举类型(字面值联合类型)时会报错</a></h2>
<p>在 KCL 中，被定义为字面值联合类型的属性，在赋值时仅允许接收一个字面值或者同为字面值联合类型的变量，比如如下代码是正确的：</p>
<pre><code class="language-python">schema Data:
    color: &quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;

data = Data {
    color = &quot;Red&quot;  # Ok, 赋值为 &quot;Red&quot;、&quot;Yellow&quot; 和 &quot;Blue&quot; 均可
} 
</code></pre>
<p>然而以下代码是错误的：</p>
<pre><code class="language-python">schema Data:
    color: &quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;

_color = &quot;Red&quot;

data = Data {
    color = _color  # Error: expect str(Red)|str(Yellow)|str(Blue), got str
} 
</code></pre>
<p>这是因为没有为变量 <code>_color</code> 申明一个类型，它会被 KCL 编译器推导为 <code>str</code> 字符串类型，因此当一个 “较大” 的类型 <code>str</code> 赋值为一个 “较小” 的类型时 <code>&quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;</code> 会报错，一个解决方式是为 <code>_color</code> 变量声明一个类型，以下代码是正确的：</p>
<pre><code class="language-python">schema Data:
    color: &quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;

_color: &quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot; = &quot;Red&quot;

data = Data {
    color = _color  # Ok
}
</code></pre>
<p>进一步地，我们可以使用类型别名来简化枚举(字面值联合类型的书写)，比如如下代码：</p>
<pre><code class="language-python">type Color = &quot;Red&quot; | &quot;Yellow&quot; | &quot;Blue&quot;  # 定义一个类型别名，可以在不同的地方重复使用，降低代码书写量

schema Data:
    color: Color

_color: Color = &quot;Red&quot;

data = Data {
    color = _color  # Ok
}
</code></pre>
<h2 id="b46-如何通过编写-kcl-插件进行扩展例如-cmdb-查询等"><a class="header" href="#b46-如何通过编写-kcl-插件进行扩展例如-cmdb-查询等">B.46. 如何通过编写 KCL 插件进行扩展（例如 CMDB 查询等）?</a></h2>
<p>KCL 插件在 KCLVM 的 plugins 子目录（通常安装在 <code>$HOME/.kusion/kclvm/plugins</code> 目录），或者通过 <code>$KCL_PLUGINS_ROOT</code> 环境变量设置（环境变量优先级更高）。对于插件开发人员，插件都在 Git 仓库管理，可以将插件仓库克隆到该目录进行开发。</p>
<p>KCL 内置了 kcl-plugin 脚手架命令用于辅助用户使用 Python 语言编写 KCL 插件，以便在 KCL 文件当中调用相应的插件对 KCL 语言本身进行增强，比如访问网络，读写 IO，CMDB 查询和加密解密等功能。</p>
<pre><code>usage: kcl-plugin [-h] {list,init,info,gendoc,test} ...

positional arguments:
  {list,init,info,gendoc,test}
                        kcl plugin sub commands
    list                list all plugins
    init                init a new plugin
    info                show plugin document
    gendoc              gen all plugins document
    test                test plugin

optional arguments:
  -h, --help            show this help message and exit
</code></pre>
<p>比如想要开发一个名为 io 插件，就可以使用如下命令成功新建一个 io 插件</p>
<pre><code>kcl-plugin init io
</code></pre>
<p>然后可以使用如下命令获得 plugin 的根路径并 cd 到相应的 io 插件目录进行开发</p>
<pre><code>kcl-plugin info
</code></pre>
<p>比如想要开发一个读文件的函数 read_file，就可以在 <code>$plugin_root/io</code> 的 <code>plugin.py</code> 中进行 python 代码编写：</p>
<pre><code class="language-python"># Copyright 2020 The KCL Authors. All rights reserved.

import pathlib

INFO = {
    'name': 'io',
    'describe': 'my io plugin description test',
    'long_describe': 'my io plugin long description test',
    'version': '0.0.1',
}


def read_file(file: str) -&gt; str:
    &quot;&quot;&quot;Read string from file&quot;&quot;&quot;
    return pathlib.Path(file).read_text()

</code></pre>
<p>另外可以在 <code>plugin_test.py</code> 中编写相应的测试函数，也可以直接编写如下所示 KCL 文件进行测试：</p>
<pre><code class="language-python">import kcl_plugin.io

text = io.read_file('test.txt')
</code></pre>
<p>还可以使用 info 命令查看 io 插件的信息</p>
<pre><code>kcl-plugin info io
</code></pre>
<pre><code>{
    &quot;name&quot;: &quot;io&quot;,
    &quot;describe&quot;: &quot;my io plugin description test&quot;,
    &quot;long_describe&quot;: &quot;my io plugin long description test&quot;,
    &quot;version&quot;: &quot;0.0.1&quot;,
    &quot;method&quot;: {
        &quot;read_file&quot;: &quot;Read string from file&quot;
    }
}
</code></pre>
<p>最后将编写测试完成的插件在 <code>kcl_plugins</code> 仓库提 MR 合并即可</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-c-链接"><a class="header" href="#附录-c-链接">附录 C: 链接</a></h1>
<ul>
<li>文档主页: <a href="https://kusionstack.io/kusion-in-action-book">https://kusionstack.io/kusion-in-action-book</a></li>
<li>Kusion 实战(电子书): <a href="https://github.com/KusionStack/kusion-in-action-book">https://github.com/KusionStack/kusion-in-action-book</a></li>
<li>开源仓库: <a href="https://github.com/KusionStack">https://github.com/KusionStack</a></li>
<li>Kusion 仓库: <a href="https://github.com/KusionStack/kusion">https://github.com/KusionStack/kusion</a></li>
<li>KCL 语言仓库: <a href="https://github.com/KusionStack/KCLVM">https://github.com/KusionStack/KCLVM</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
